// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: db.proto

#include "db.pb.h"

#include <algorithm>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/descriptor.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/reflection_ops.h"
#include "google/protobuf/wire_format.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = ::PROTOBUF_NAMESPACE_ID::internal;
namespace pbdb {
template <typename>
PROTOBUF_CONSTEXPR db_account::db_account(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.m_account_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.m_passworld_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.m_id_)*/ ::int64_t{0}

  , /*decltype(_impl_.m_roleid_)*/ ::int64_t{0}

  , /*decltype(_impl_.m_area_)*/ 0
} {}
struct db_accountDefaultTypeInternal {
  PROTOBUF_CONSTEXPR db_accountDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~db_accountDefaultTypeInternal() {}
  union {
    db_account _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 db_accountDefaultTypeInternal _db_account_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR db_brief::db_brief(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.m_name_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.m_id_)*/ ::int64_t{0}

  , /*decltype(_impl_.m_lv_)*/ 0

  , /*decltype(_impl_.m_moneygold_)*/ 0

  , /*decltype(_impl_.m_moneysilver_)*/ 0
} {}
struct db_briefDefaultTypeInternal {
  PROTOBUF_CONSTEXPR db_briefDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~db_briefDefaultTypeInternal() {}
  union {
    db_brief _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 db_briefDefaultTypeInternal _db_brief_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR db_role::db_role(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.m_base_)*/nullptr
  , /*decltype(_impl_.m_id_)*/ ::int64_t{0}
} {}
struct db_roleDefaultTypeInternal {
  PROTOBUF_CONSTEXPR db_roleDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~db_roleDefaultTypeInternal() {}
  union {
    db_role _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 db_roleDefaultTypeInternal _db_role_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR item::item(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.m_id_)*/ 0

  , /*decltype(_impl_.m_tid_)*/ 0

  , /*decltype(_impl_.m_count_)*/ 0

  , /*decltype(_impl_.m_lv_)*/ 0

  , /*decltype(_impl_.m_star_)*/ 0
} {}
struct itemDefaultTypeInternal {
  PROTOBUF_CONSTEXPR itemDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~itemDefaultTypeInternal() {}
  union {
    item _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 itemDefaultTypeInternal _item_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR db_bag_MItemsEntry_DoNotUse::db_bag_MItemsEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct db_bag_MItemsEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR db_bag_MItemsEntry_DoNotUseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~db_bag_MItemsEntry_DoNotUseDefaultTypeInternal() {}
  union {
    db_bag_MItemsEntry_DoNotUse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 db_bag_MItemsEntry_DoNotUseDefaultTypeInternal _db_bag_MItemsEntry_DoNotUse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR db_bag::db_bag(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.m_items_)*/{}
  , /*decltype(_impl_.m_id_)*/ ::int64_t{0}

  , /*decltype(_impl_.m_maxid_)*/ 0
} {}
struct db_bagDefaultTypeInternal {
  PROTOBUF_CONSTEXPR db_bagDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~db_bagDefaultTypeInternal() {}
  union {
    db_bag _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 db_bagDefaultTypeInternal _db_bag_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR db_keyvalue::db_keyvalue(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.m_key_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.m_value_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.m_id_)*/ ::int64_t{0}
} {}
struct db_keyvalueDefaultTypeInternal {
  PROTOBUF_CONSTEXPR db_keyvalueDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~db_keyvalueDefaultTypeInternal() {}
  union {
    db_keyvalue _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 db_keyvalueDefaultTypeInternal _db_keyvalue_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR mailitem::mailitem(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.m_itemtid_)*/ 0

  , /*decltype(_impl_.m_count_)*/ 0
} {}
struct mailitemDefaultTypeInternal {
  PROTOBUF_CONSTEXPR mailitemDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~mailitemDefaultTypeInternal() {}
  union {
    mailitem _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 mailitemDefaultTypeInternal _mailitem_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR mail::mail(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.m_items_)*/{}
  , /*decltype(_impl_.m_prams_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.m_id_)*/ 0

  , /*decltype(_impl_.m_createutc_)*/ 0

  , /*decltype(_impl_.m_tid_)*/ 0

  , /*decltype(_impl_.m_read_)*/ false

  , /*decltype(_impl_.m_draw_)*/ false
} {}
struct mailDefaultTypeInternal {
  PROTOBUF_CONSTEXPR mailDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~mailDefaultTypeInternal() {}
  union {
    mail _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 mailDefaultTypeInternal _mail_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR db_mail_MMailEntry_DoNotUse::db_mail_MMailEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct db_mail_MMailEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR db_mail_MMailEntry_DoNotUseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~db_mail_MMailEntry_DoNotUseDefaultTypeInternal() {}
  union {
    db_mail_MMailEntry_DoNotUse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 db_mail_MMailEntry_DoNotUseDefaultTypeInternal _db_mail_MMailEntry_DoNotUse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR db_mail::db_mail(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.m_mail_)*/{}
  , /*decltype(_impl_.m_id_)*/ ::int64_t{0}
} {}
struct db_mailDefaultTypeInternal {
  PROTOBUF_CONSTEXPR db_mailDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~db_mailDefaultTypeInternal() {}
  union {
    db_mail _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 db_mailDefaultTypeInternal _db_mail_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR db_guild::db_guild(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.m_members_)*/ {}
  ,/* _impl_._m_members_cached_byte_size_ = */ { 0 }

  , /*decltype(_impl_.m_guild_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.m_id_)*/ ::int64_t{0}

  , /*decltype(_impl_.m_leader_)*/ ::int64_t{0}
} {}
struct db_guildDefaultTypeInternal {
  PROTOBUF_CONSTEXPR db_guildDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~db_guildDefaultTypeInternal() {}
  union {
    db_guild _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 db_guildDefaultTypeInternal _db_guild_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR db_notice::db_notice(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.m_notice_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.m_id_)*/ ::int64_t{0}

  , /*decltype(_impl_.m_starttime_)*/ 0

  , /*decltype(_impl_.m_finishtime_)*/ 0
} {}
struct db_noticeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR db_noticeDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~db_noticeDefaultTypeInternal() {}
  union {
    db_notice _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 db_noticeDefaultTypeInternal _db_notice_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR rankitem::rankitem(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.m_name_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.m_roleid_)*/ ::int64_t{0}

  , /*decltype(_impl_.m_lv_)*/ 0

  , /*decltype(_impl_.m_lvtime_)*/ 0
} {}
struct rankitemDefaultTypeInternal {
  PROTOBUF_CONSTEXPR rankitemDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~rankitemDefaultTypeInternal() {}
  union {
    rankitem _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 rankitemDefaultTypeInternal _rankitem_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR db_ranklist_MItemEntry_DoNotUse::db_ranklist_MItemEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct db_ranklist_MItemEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR db_ranklist_MItemEntry_DoNotUseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~db_ranklist_MItemEntry_DoNotUseDefaultTypeInternal() {}
  union {
    db_ranklist_MItemEntry_DoNotUse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 db_ranklist_MItemEntry_DoNotUseDefaultTypeInternal _db_ranklist_MItemEntry_DoNotUse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR db_ranklist::db_ranklist(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.m_item_)*/{}
  , /*decltype(_impl_.m_id_)*/ ::int64_t{0}
} {}
struct db_ranklistDefaultTypeInternal {
  PROTOBUF_CONSTEXPR db_ranklistDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~db_ranklistDefaultTypeInternal() {}
  union {
    db_ranklist _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 db_ranklistDefaultTypeInternal _db_ranklist_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR db_activity_data_drawcompliance::db_activity_data_drawcompliance(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.m_reward_)*/ {}
  ,/* _impl_._m_reward_cached_byte_size_ = */ { 0 }

  , /*decltype(_impl_.m_count_)*/ 0
} {}
struct db_activity_data_drawcomplianceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR db_activity_data_drawcomplianceDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~db_activity_data_drawcomplianceDefaultTypeInternal() {}
  union {
    db_activity_data_drawcompliance _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 db_activity_data_drawcomplianceDefaultTypeInternal _db_activity_data_drawcompliance_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR db_activity_data_MDrawcomplianceEntry_DoNotUse::db_activity_data_MDrawcomplianceEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct db_activity_data_MDrawcomplianceEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR db_activity_data_MDrawcomplianceEntry_DoNotUseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~db_activity_data_MDrawcomplianceEntry_DoNotUseDefaultTypeInternal() {}
  union {
    db_activity_data_MDrawcomplianceEntry_DoNotUse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 db_activity_data_MDrawcomplianceEntry_DoNotUseDefaultTypeInternal _db_activity_data_MDrawcomplianceEntry_DoNotUse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR db_activity_data::db_activity_data(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.m_drawcompliance_)*/{}
  , /*decltype(_impl_.m_beg_)*/ 0

  , /*decltype(_impl_.m_end_)*/ 0

  , /*decltype(_impl_.m_start_)*/ false

  , /*decltype(_impl_.m_finish_)*/ false
} {}
struct db_activity_dataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR db_activity_dataDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~db_activity_dataDefaultTypeInternal() {}
  union {
    db_activity_data _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 db_activity_dataDefaultTypeInternal _db_activity_data_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR db_activity::db_activity(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.m_datas_)*/{}
  , /*decltype(_impl_.m_id_)*/ ::int64_t{0}
} {}
struct db_activityDefaultTypeInternal {
  PROTOBUF_CONSTEXPR db_activityDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~db_activityDefaultTypeInternal() {}
  union {
    db_activity _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 db_activityDefaultTypeInternal _db_activity_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR db_task_data_schedule::db_task_data_schedule(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.m_parmint_)*/ {}
  ,/* _impl_._m_parmint_cached_byte_size_ = */ { 0 }

  , /*decltype(_impl_.m_sumint_)*/ {}
  ,/* _impl_._m_sumint_cached_byte_size_ = */ { 0 }

  , /*decltype(_impl_.m_type_)*/ 0
} {}
struct db_task_data_scheduleDefaultTypeInternal {
  PROTOBUF_CONSTEXPR db_task_data_scheduleDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~db_task_data_scheduleDefaultTypeInternal() {}
  union {
    db_task_data_schedule _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 db_task_data_scheduleDefaultTypeInternal _db_task_data_schedule_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR db_task_data::db_task_data(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.m_schedules_)*/{}
  , /*decltype(_impl_.m_taskid_)*/ 0

  , /*decltype(_impl_.m_receiveutc_)*/ 0

  , /*decltype(_impl_.m_finshutc_)*/ 0
} {}
struct db_task_dataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR db_task_dataDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~db_task_dataDefaultTypeInternal() {}
  union {
    db_task_data _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 db_task_dataDefaultTypeInternal _db_task_data_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR db_task_MRundatasEntry_DoNotUse::db_task_MRundatasEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct db_task_MRundatasEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR db_task_MRundatasEntry_DoNotUseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~db_task_MRundatasEntry_DoNotUseDefaultTypeInternal() {}
  union {
    db_task_MRundatasEntry_DoNotUse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 db_task_MRundatasEntry_DoNotUseDefaultTypeInternal _db_task_MRundatasEntry_DoNotUse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR db_task_MCompleteddatasEntry_DoNotUse::db_task_MCompleteddatasEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct db_task_MCompleteddatasEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR db_task_MCompleteddatasEntry_DoNotUseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~db_task_MCompleteddatasEntry_DoNotUseDefaultTypeInternal() {}
  union {
    db_task_MCompleteddatasEntry_DoNotUse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 db_task_MCompleteddatasEntry_DoNotUseDefaultTypeInternal _db_task_MCompleteddatasEntry_DoNotUse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR db_task::db_task(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.m_rundatas_)*/{}
  , /*decltype(_impl_.m_completeddatas_)*/{}
  , /*decltype(_impl_.m_id_)*/ ::int64_t{0}
} {}
struct db_taskDefaultTypeInternal {
  PROTOBUF_CONSTEXPR db_taskDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~db_taskDefaultTypeInternal() {}
  union {
    db_task _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 db_taskDefaultTypeInternal _db_task_default_instance_;
}  // namespace pbdb
static ::_pb::Metadata file_level_metadata_db_2eproto[25];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_db_2eproto[1];
static constexpr const ::_pb::ServiceDescriptor**
    file_level_service_descriptors_db_2eproto = nullptr;
const ::uint32_t TableStruct_db_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(
    protodesc_cold) = {
    PROTOBUF_FIELD_OFFSET(::pbdb::db_account, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::pbdb::db_account, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::pbdb::db_account, _impl_.m_id_),
    PROTOBUF_FIELD_OFFSET(::pbdb::db_account, _impl_.m_roleid_),
    PROTOBUF_FIELD_OFFSET(::pbdb::db_account, _impl_.m_account_),
    PROTOBUF_FIELD_OFFSET(::pbdb::db_account, _impl_.m_passworld_),
    PROTOBUF_FIELD_OFFSET(::pbdb::db_account, _impl_.m_area_),
    2,
    3,
    0,
    1,
    4,
    PROTOBUF_FIELD_OFFSET(::pbdb::db_brief, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::pbdb::db_brief, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::pbdb::db_brief, _impl_.m_id_),
    PROTOBUF_FIELD_OFFSET(::pbdb::db_brief, _impl_.m_name_),
    PROTOBUF_FIELD_OFFSET(::pbdb::db_brief, _impl_.m_lv_),
    PROTOBUF_FIELD_OFFSET(::pbdb::db_brief, _impl_.m_moneygold_),
    PROTOBUF_FIELD_OFFSET(::pbdb::db_brief, _impl_.m_moneysilver_),
    1,
    0,
    2,
    3,
    4,
    PROTOBUF_FIELD_OFFSET(::pbdb::db_role, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::pbdb::db_role, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::pbdb::db_role, _impl_.m_id_),
    PROTOBUF_FIELD_OFFSET(::pbdb::db_role, _impl_.m_base_),
    1,
    0,
    PROTOBUF_FIELD_OFFSET(::pbdb::item, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::pbdb::item, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::pbdb::item, _impl_.m_id_),
    PROTOBUF_FIELD_OFFSET(::pbdb::item, _impl_.m_tid_),
    PROTOBUF_FIELD_OFFSET(::pbdb::item, _impl_.m_count_),
    PROTOBUF_FIELD_OFFSET(::pbdb::item, _impl_.m_lv_),
    PROTOBUF_FIELD_OFFSET(::pbdb::item, _impl_.m_star_),
    0,
    1,
    2,
    3,
    4,
    PROTOBUF_FIELD_OFFSET(::pbdb::db_bag_MItemsEntry_DoNotUse, _has_bits_),
    PROTOBUF_FIELD_OFFSET(::pbdb::db_bag_MItemsEntry_DoNotUse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::pbdb::db_bag_MItemsEntry_DoNotUse, key_),
    PROTOBUF_FIELD_OFFSET(::pbdb::db_bag_MItemsEntry_DoNotUse, value_),
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::pbdb::db_bag, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::pbdb::db_bag, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::pbdb::db_bag, _impl_.m_id_),
    PROTOBUF_FIELD_OFFSET(::pbdb::db_bag, _impl_.m_items_),
    PROTOBUF_FIELD_OFFSET(::pbdb::db_bag, _impl_.m_maxid_),
    0,
    ~0u,
    1,
    PROTOBUF_FIELD_OFFSET(::pbdb::db_keyvalue, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::pbdb::db_keyvalue, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::pbdb::db_keyvalue, _impl_.m_id_),
    PROTOBUF_FIELD_OFFSET(::pbdb::db_keyvalue, _impl_.m_key_),
    PROTOBUF_FIELD_OFFSET(::pbdb::db_keyvalue, _impl_.m_value_),
    2,
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::pbdb::mailitem, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::pbdb::mailitem, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::pbdb::mailitem, _impl_.m_itemtid_),
    PROTOBUF_FIELD_OFFSET(::pbdb::mailitem, _impl_.m_count_),
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::pbdb::mail, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::pbdb::mail, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::pbdb::mail, _impl_.m_id_),
    PROTOBUF_FIELD_OFFSET(::pbdb::mail, _impl_.m_createutc_),
    PROTOBUF_FIELD_OFFSET(::pbdb::mail, _impl_.m_tid_),
    PROTOBUF_FIELD_OFFSET(::pbdb::mail, _impl_.m_prams_),
    PROTOBUF_FIELD_OFFSET(::pbdb::mail, _impl_.m_items_),
    PROTOBUF_FIELD_OFFSET(::pbdb::mail, _impl_.m_read_),
    PROTOBUF_FIELD_OFFSET(::pbdb::mail, _impl_.m_draw_),
    1,
    2,
    3,
    0,
    ~0u,
    4,
    5,
    PROTOBUF_FIELD_OFFSET(::pbdb::db_mail_MMailEntry_DoNotUse, _has_bits_),
    PROTOBUF_FIELD_OFFSET(::pbdb::db_mail_MMailEntry_DoNotUse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::pbdb::db_mail_MMailEntry_DoNotUse, key_),
    PROTOBUF_FIELD_OFFSET(::pbdb::db_mail_MMailEntry_DoNotUse, value_),
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::pbdb::db_mail, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::pbdb::db_mail, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::pbdb::db_mail, _impl_.m_id_),
    PROTOBUF_FIELD_OFFSET(::pbdb::db_mail, _impl_.m_mail_),
    0,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::pbdb::db_guild, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::pbdb::db_guild, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::pbdb::db_guild, _impl_.m_id_),
    PROTOBUF_FIELD_OFFSET(::pbdb::db_guild, _impl_.m_guild_),
    PROTOBUF_FIELD_OFFSET(::pbdb::db_guild, _impl_.m_leader_),
    PROTOBUF_FIELD_OFFSET(::pbdb::db_guild, _impl_.m_members_),
    1,
    0,
    2,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::pbdb::db_notice, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::pbdb::db_notice, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::pbdb::db_notice, _impl_.m_id_),
    PROTOBUF_FIELD_OFFSET(::pbdb::db_notice, _impl_.m_notice_),
    PROTOBUF_FIELD_OFFSET(::pbdb::db_notice, _impl_.m_starttime_),
    PROTOBUF_FIELD_OFFSET(::pbdb::db_notice, _impl_.m_finishtime_),
    1,
    0,
    2,
    3,
    PROTOBUF_FIELD_OFFSET(::pbdb::rankitem, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::pbdb::rankitem, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::pbdb::rankitem, _impl_.m_roleid_),
    PROTOBUF_FIELD_OFFSET(::pbdb::rankitem, _impl_.m_name_),
    PROTOBUF_FIELD_OFFSET(::pbdb::rankitem, _impl_.m_lv_),
    PROTOBUF_FIELD_OFFSET(::pbdb::rankitem, _impl_.m_lvtime_),
    1,
    0,
    2,
    3,
    PROTOBUF_FIELD_OFFSET(::pbdb::db_ranklist_MItemEntry_DoNotUse, _has_bits_),
    PROTOBUF_FIELD_OFFSET(::pbdb::db_ranklist_MItemEntry_DoNotUse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::pbdb::db_ranklist_MItemEntry_DoNotUse, key_),
    PROTOBUF_FIELD_OFFSET(::pbdb::db_ranklist_MItemEntry_DoNotUse, value_),
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::pbdb::db_ranklist, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::pbdb::db_ranklist, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::pbdb::db_ranklist, _impl_.m_id_),
    PROTOBUF_FIELD_OFFSET(::pbdb::db_ranklist, _impl_.m_item_),
    0,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::pbdb::db_activity_data_drawcompliance, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::pbdb::db_activity_data_drawcompliance, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::pbdb::db_activity_data_drawcompliance, _impl_.m_count_),
    PROTOBUF_FIELD_OFFSET(::pbdb::db_activity_data_drawcompliance, _impl_.m_reward_),
    0,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::pbdb::db_activity_data_MDrawcomplianceEntry_DoNotUse, _has_bits_),
    PROTOBUF_FIELD_OFFSET(::pbdb::db_activity_data_MDrawcomplianceEntry_DoNotUse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::pbdb::db_activity_data_MDrawcomplianceEntry_DoNotUse, key_),
    PROTOBUF_FIELD_OFFSET(::pbdb::db_activity_data_MDrawcomplianceEntry_DoNotUse, value_),
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::pbdb::db_activity_data, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::pbdb::db_activity_data, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::pbdb::db_activity_data, _impl_.m_beg_),
    PROTOBUF_FIELD_OFFSET(::pbdb::db_activity_data, _impl_.m_end_),
    PROTOBUF_FIELD_OFFSET(::pbdb::db_activity_data, _impl_.m_start_),
    PROTOBUF_FIELD_OFFSET(::pbdb::db_activity_data, _impl_.m_finish_),
    PROTOBUF_FIELD_OFFSET(::pbdb::db_activity_data, _impl_.m_drawcompliance_),
    0,
    1,
    2,
    3,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::pbdb::db_activity, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::pbdb::db_activity, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::pbdb::db_activity, _impl_.m_id_),
    PROTOBUF_FIELD_OFFSET(::pbdb::db_activity, _impl_.m_datas_),
    0,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::pbdb::db_task_data_schedule, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::pbdb::db_task_data_schedule, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::pbdb::db_task_data_schedule, _impl_.m_type_),
    PROTOBUF_FIELD_OFFSET(::pbdb::db_task_data_schedule, _impl_.m_parmint_),
    PROTOBUF_FIELD_OFFSET(::pbdb::db_task_data_schedule, _impl_.m_sumint_),
    0,
    ~0u,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::pbdb::db_task_data, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::pbdb::db_task_data, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::pbdb::db_task_data, _impl_.m_taskid_),
    PROTOBUF_FIELD_OFFSET(::pbdb::db_task_data, _impl_.m_receiveutc_),
    PROTOBUF_FIELD_OFFSET(::pbdb::db_task_data, _impl_.m_finshutc_),
    PROTOBUF_FIELD_OFFSET(::pbdb::db_task_data, _impl_.m_schedules_),
    0,
    1,
    2,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::pbdb::db_task_MRundatasEntry_DoNotUse, _has_bits_),
    PROTOBUF_FIELD_OFFSET(::pbdb::db_task_MRundatasEntry_DoNotUse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::pbdb::db_task_MRundatasEntry_DoNotUse, key_),
    PROTOBUF_FIELD_OFFSET(::pbdb::db_task_MRundatasEntry_DoNotUse, value_),
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::pbdb::db_task_MCompleteddatasEntry_DoNotUse, _has_bits_),
    PROTOBUF_FIELD_OFFSET(::pbdb::db_task_MCompleteddatasEntry_DoNotUse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::pbdb::db_task_MCompleteddatasEntry_DoNotUse, key_),
    PROTOBUF_FIELD_OFFSET(::pbdb::db_task_MCompleteddatasEntry_DoNotUse, value_),
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::pbdb::db_task, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::pbdb::db_task, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::pbdb::db_task, _impl_.m_id_),
    PROTOBUF_FIELD_OFFSET(::pbdb::db_task, _impl_.m_rundatas_),
    PROTOBUF_FIELD_OFFSET(::pbdb::db_task, _impl_.m_completeddatas_),
    0,
    ~0u,
    ~0u,
};

static const ::_pbi::MigrationSchema
    schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
        { 0, 13, -1, sizeof(::pbdb::db_account)},
        { 18, 31, -1, sizeof(::pbdb::db_brief)},
        { 36, 46, -1, sizeof(::pbdb::db_role)},
        { 48, 61, -1, sizeof(::pbdb::item)},
        { 66, 76, -1, sizeof(::pbdb::db_bag_MItemsEntry_DoNotUse)},
        { 78, 89, -1, sizeof(::pbdb::db_bag)},
        { 92, 103, -1, sizeof(::pbdb::db_keyvalue)},
        { 106, 116, -1, sizeof(::pbdb::mailitem)},
        { 118, 133, -1, sizeof(::pbdb::mail)},
        { 140, 150, -1, sizeof(::pbdb::db_mail_MMailEntry_DoNotUse)},
        { 152, 162, -1, sizeof(::pbdb::db_mail)},
        { 164, 176, -1, sizeof(::pbdb::db_guild)},
        { 180, 192, -1, sizeof(::pbdb::db_notice)},
        { 196, 208, -1, sizeof(::pbdb::rankitem)},
        { 212, 222, -1, sizeof(::pbdb::db_ranklist_MItemEntry_DoNotUse)},
        { 224, 234, -1, sizeof(::pbdb::db_ranklist)},
        { 236, 246, -1, sizeof(::pbdb::db_activity_data_drawcompliance)},
        { 248, 258, -1, sizeof(::pbdb::db_activity_data_MDrawcomplianceEntry_DoNotUse)},
        { 260, 273, -1, sizeof(::pbdb::db_activity_data)},
        { 278, 288, -1, sizeof(::pbdb::db_activity)},
        { 290, 301, -1, sizeof(::pbdb::db_task_data_schedule)},
        { 304, 316, -1, sizeof(::pbdb::db_task_data)},
        { 320, 330, -1, sizeof(::pbdb::db_task_MRundatasEntry_DoNotUse)},
        { 332, 342, -1, sizeof(::pbdb::db_task_MCompleteddatasEntry_DoNotUse)},
        { 344, 355, -1, sizeof(::pbdb::db_task)},
};

static const ::_pb::Message* const file_default_instances[] = {
    &::pbdb::_db_account_default_instance_._instance,
    &::pbdb::_db_brief_default_instance_._instance,
    &::pbdb::_db_role_default_instance_._instance,
    &::pbdb::_item_default_instance_._instance,
    &::pbdb::_db_bag_MItemsEntry_DoNotUse_default_instance_._instance,
    &::pbdb::_db_bag_default_instance_._instance,
    &::pbdb::_db_keyvalue_default_instance_._instance,
    &::pbdb::_mailitem_default_instance_._instance,
    &::pbdb::_mail_default_instance_._instance,
    &::pbdb::_db_mail_MMailEntry_DoNotUse_default_instance_._instance,
    &::pbdb::_db_mail_default_instance_._instance,
    &::pbdb::_db_guild_default_instance_._instance,
    &::pbdb::_db_notice_default_instance_._instance,
    &::pbdb::_rankitem_default_instance_._instance,
    &::pbdb::_db_ranklist_MItemEntry_DoNotUse_default_instance_._instance,
    &::pbdb::_db_ranklist_default_instance_._instance,
    &::pbdb::_db_activity_data_drawcompliance_default_instance_._instance,
    &::pbdb::_db_activity_data_MDrawcomplianceEntry_DoNotUse_default_instance_._instance,
    &::pbdb::_db_activity_data_default_instance_._instance,
    &::pbdb::_db_activity_default_instance_._instance,
    &::pbdb::_db_task_data_schedule_default_instance_._instance,
    &::pbdb::_db_task_data_default_instance_._instance,
    &::pbdb::_db_task_MRundatasEntry_DoNotUse_default_instance_._instance,
    &::pbdb::_db_task_MCompleteddatasEntry_DoNotUse_default_instance_._instance,
    &::pbdb::_db_task_default_instance_._instance,
};
const char descriptor_table_protodef_db_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
    "\n\010db.proto\022\004pbdb\"\274\001\n\ndb_account\022\021\n\004m_id\030"
    "\001 \001(\003H\000\210\001\001\022\025\n\010m_roleid\030\002 \001(\003H\001\210\001\001\022\026\n\tm_a"
    "ccount\030\003 \001(\tH\002\210\001\001\022\030\n\013m_passworld\030\004 \001(\tH\003"
    "\210\001\001\022\023\n\006m_area\030\005 \001(\005H\004\210\001\001B\007\n\005_m_idB\013\n\t_m_"
    "roleidB\014\n\n_m_accountB\016\n\014_m_passworldB\t\n\007"
    "_m_area\"\272\001\n\010db_brief\022\021\n\004m_id\030\001 \001(\003H\000\210\001\001\022"
    "\023\n\006m_name\030\002 \001(\tH\001\210\001\001\022\021\n\004m_lv\030\003 \001(\005H\002\210\001\001\022"
    "\030\n\013m_moneygold\030\004 \001(\005H\003\210\001\001\022\032\n\rm_moneysilv"
    "er\030\005 \001(\005H\004\210\001\001B\007\n\005_m_idB\t\n\007_m_nameB\007\n\005_m_"
    "lvB\016\n\014_m_moneygoldB\020\n\016_m_moneysilver\"U\n\007"
    "db_role\022\021\n\004m_id\030\001 \001(\003H\000\210\001\001\022#\n\006m_base\030\002 \001"
    "(\0132\016.pbdb.db_briefH\001\210\001\001B\007\n\005_m_idB\t\n\007_m_b"
    "ase\"\236\001\n\004item\022\021\n\004m_id\030\001 \001(\005H\000\210\001\001\022\022\n\005m_tid"
    "\030\002 \001(\005H\001\210\001\001\022\024\n\007m_count\030\003 \001(\005H\002\210\001\001\022\021\n\004m_l"
    "v\030\004 \001(\005H\003\210\001\001\022\023\n\006m_star\030\005 \001(\005H\004\210\001\001B\007\n\005_m_"
    "idB\010\n\006_m_tidB\n\n\010_m_countB\007\n\005_m_lvB\t\n\007_m_"
    "star\"\254\001\n\006db_bag\022\021\n\004m_id\030\001 \001(\003H\000\210\001\001\022)\n\007m_"
    "items\030\002 \003(\0132\030.pbdb.db_bag.MItemsEntry\022\024\n"
    "\007m_maxid\030\003 \001(\005H\001\210\001\001\0329\n\013MItemsEntry\022\013\n\003ke"
    "y\030\001 \001(\005\022\031\n\005value\030\002 \001(\0132\n.pbdb.item:\0028\001B\007"
    "\n\005_m_idB\n\n\010_m_maxid\"i\n\013db_keyvalue\022\021\n\004m_"
    "id\030\001 \001(\003H\000\210\001\001\022\022\n\005m_key\030\002 \001(\tH\001\210\001\001\022\024\n\007m_v"
    "alue\030\003 \001(\tH\002\210\001\001B\007\n\005_m_idB\010\n\006_m_keyB\n\n\010_m"
    "_value\"R\n\010mailitem\022\026\n\tm_itemtid\030\001 \001(\005H\000\210"
    "\001\001\022\024\n\007m_count\030\002 \001(\005H\001\210\001\001B\014\n\n_m_itemtidB\n"
    "\n\010_m_count\"\355\001\n\004mail\022\021\n\004m_id\030\001 \001(\005H\000\210\001\001\022\030"
    "\n\013m_createutc\030\002 \001(\005H\001\210\001\001\022\022\n\005m_tid\030\003 \001(\005H"
    "\002\210\001\001\022\024\n\007m_prams\030\004 \001(\tH\003\210\001\001\022\037\n\007m_items\030\005 "
    "\003(\0132\016.pbdb.mailitem\022\023\n\006m_read\030\006 \001(\010H\004\210\001\001"
    "\022\023\n\006m_draw\030\007 \001(\010H\005\210\001\001B\007\n\005_m_idB\016\n\014_m_cre"
    "ateutcB\010\n\006_m_tidB\n\n\010_m_pramsB\t\n\007_m_readB"
    "\t\n\007_m_draw\"\211\001\n\007db_mail\022\021\n\004m_id\030\001 \001(\003H\000\210\001"
    "\001\022(\n\006m_mail\030\002 \003(\0132\030.pbdb.db_mail.MMailEn"
    "try\0328\n\nMMailEntry\022\013\n\003key\030\001 \001(\005\022\031\n\005value\030"
    "\002 \001(\0132\n.pbdb.mail:\0028\001B\007\n\005_m_id\"\177\n\010db_gui"
    "ld\022\021\n\004m_id\030\001 \001(\003H\000\210\001\001\022\024\n\007m_guild\030\002 \001(\tH\001"
    "\210\001\001\022\025\n\010m_leader\030\003 \001(\003H\002\210\001\001\022\021\n\tm_members\030"
    "\004 \003(\003B\007\n\005_m_idB\n\n\010_m_guildB\013\n\t_m_leader\""
    "\241\001\n\tdb_notice\022\021\n\004m_id\030\001 \001(\003H\000\210\001\001\022\025\n\010m_no"
    "tice\030\002 \001(\tH\001\210\001\001\022\030\n\013m_starttime\030\003 \001(\005H\002\210\001"
    "\001\022\031\n\014m_finishtime\030\004 \001(\005H\003\210\001\001B\007\n\005_m_idB\013\n"
    "\t_m_noticeB\016\n\014_m_starttimeB\017\n\r_m_finisht"
    "ime\"\216\001\n\010rankitem\022\025\n\010m_roleid\030\001 \001(\003H\000\210\001\001\022"
    "\023\n\006m_name\030\002 \001(\tH\001\210\001\001\022\021\n\004m_lv\030\003 \001(\005H\002\210\001\001\022"
    "\025\n\010m_lvtime\030\004 \001(\005H\003\210\001\001B\013\n\t_m_roleidB\t\n\007_"
    "m_nameB\007\n\005_m_lvB\013\n\t_m_lvtime\"\225\001\n\013db_rank"
    "list\022\021\n\004m_id\030\001 \001(\003H\000\210\001\001\022,\n\006m_item\030\002 \003(\0132"
    "\034.pbdb.db_ranklist.MItemEntry\032<\n\nMItemEn"
    "try\022\013\n\003key\030\001 \001(\003\022\035\n\005value\030\002 \001(\0132\016.pbdb.r"
    "ankitem:\0028\001B\007\n\005_m_id\"\311\003\n\013db_activity\022\021\n\004"
    "m_id\030\001 \001(\003H\000\210\001\001\022\'\n\007m_datas\030\002 \003(\0132\026.pbdb."
    "db_activity.data\032\364\002\n\004data\022\022\n\005m_beg\030\002 \001(\005"
    "H\000\210\001\001\022\022\n\005m_end\030\003 \001(\005H\001\210\001\001\022\024\n\007m_start\030\004 \001"
    "(\010H\002\210\001\001\022\025\n\010m_finish\030\005 \001(\010H\003\210\001\001\022E\n\020m_draw"
    "compliance\030\006 \003(\0132+.pbdb.db_activity.data"
    ".MDrawcomplianceEntry\032D\n\016drawcompliance\022"
    "\024\n\007m_count\030\001 \001(\005H\000\210\001\001\022\020\n\010m_reward\030\002 \003(\005B"
    "\n\n\010_m_count\032]\n\024MDrawcomplianceEntry\022\013\n\003k"
    "ey\030\001 \001(\003\0224\n\005value\030\002 \001(\0132%.pbdb.db_activi"
    "ty.data.drawcompliance:\0028\001B\010\n\006_m_begB\010\n\006"
    "_m_endB\n\n\010_m_startB\013\n\t_m_finishB\007\n\005_m_id"
    "\"\260\004\n\007db_task\022\021\n\004m_id\030\001 \001(\003H\000\210\001\001\0220\n\nm_run"
    "datas\030\002 \003(\0132\034.pbdb.db_task.MRundatasEntr"
    "y\022<\n\020m_completeddatas\030\003 \003(\0132\".pbdb.db_ta"
    "sk.MCompleteddatasEntry\032T\n\rdata_schedule"
    "\022\023\n\006m_type\030\001 \001(\005H\000\210\001\001\022\021\n\tm_parmint\030\002 \003(\005"
    "\022\020\n\010m_sumint\030\003 \003(\005B\t\n\007_m_type\032\260\001\n\004data\022\025"
    "\n\010m_taskid\030\001 \001(\005H\000\210\001\001\022\031\n\014m_receiveutc\030\002 "
    "\001(\005H\001\210\001\001\022\027\n\nm_finshutc\030\003 \001(\005H\002\210\001\001\0220\n\013m_s"
    "chedules\030\004 \003(\0132\033.pbdb.db_task.data_sched"
    "uleB\013\n\t_m_taskidB\017\n\r_m_receiveutcB\r\n\013_m_"
    "finshutc\032D\n\016MRundatasEntry\022\013\n\003key\030\001 \001(\005\022"
    "!\n\005value\030\002 \001(\0132\022.pbdb.db_task.data:\0028\001\032J"
    "\n\024MCompleteddatasEntry\022\013\n\003key\030\001 \001(\005\022!\n\005v"
    "alue\030\002 \001(\0132\022.pbdb.db_task.data:\0028\001B\007\n\005_m"
    "_id*\364\001\n\007ENUM_DB\022\023\n\017ENUM_DB_ACCOUNT\020\000\022\020\n\014"
    "ENUM_DB_ROLE\020\001\022\021\n\rENUM_DB_BRIEF\020\002\022\017\n\013ENU"
    "M_DB_BAG\020\003\022\024\n\020ENUM_DB_KEYVALUE\020\004\022\020\n\014ENUM"
    "_DB_MAIL\020\005\022\021\n\rENUM_DB_GUILD\020\006\022\022\n\016ENUM_DB"
    "_NOTICE\020\007\022\024\n\020ENUM_DB_RANKLIST\020\010\022\024\n\020ENUM_"
    "DB_ACTIVITY\020\t\022\020\n\014ENUM_DB_TASK\020\n\022\021\n\rENUM_"
    "DB_COUNT\020\013b\006proto3"
};
static ::absl::once_flag descriptor_table_db_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_db_2eproto = {
    false,
    false,
    3258,
    descriptor_table_protodef_db_2eproto,
    "db.proto",
    &descriptor_table_db_2eproto_once,
    nullptr,
    0,
    25,
    schemas,
    file_default_instances,
    TableStruct_db_2eproto::offsets,
    file_level_metadata_db_2eproto,
    file_level_enum_descriptors_db_2eproto,
    file_level_service_descriptors_db_2eproto,
};

// This function exists to be marked as weak.
// It can significantly speed up compilation by breaking up LLVM's SCC
// in the .pb.cc translation units. Large translation units see a
// reduction of more than 35% of walltime for optimized builds. Without
// the weak attribute all the messages in the file, including all the
// vtables and everything they use become part of the same SCC through
// a cycle like:
// GetMetadata -> descriptor table -> default instances ->
//   vtables -> GetMetadata
// By adding a weak function here we break the connection from the
// individual vtables back into the descriptor table.
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_db_2eproto_getter() {
  return &descriptor_table_db_2eproto;
}
// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2
static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_db_2eproto(&descriptor_table_db_2eproto);
namespace pbdb {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ENUM_DB_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_db_2eproto);
  return file_level_enum_descriptors_db_2eproto[0];
}
bool ENUM_DB_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
      return true;
    default:
      return false;
  }
}
// ===================================================================

class db_account::_Internal {
 public:
  using HasBits = decltype(std::declval<db_account>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(db_account, _impl_._has_bits_);
  static void set_has_m_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_m_roleid(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_m_account(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_m_passworld(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_m_area(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

db_account::db_account(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pbdb.db_account)
}
db_account::db_account(const db_account& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  db_account* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.m_account_) {}

    , decltype(_impl_.m_passworld_) {}

    , decltype(_impl_.m_id_) {}

    , decltype(_impl_.m_roleid_) {}

    , decltype(_impl_.m_area_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.m_account_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.m_account_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.m_account_.Set(from._internal_m_account(), _this->GetArenaForAllocation());
  }
  _impl_.m_passworld_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.m_passworld_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.m_passworld_.Set(from._internal_m_passworld(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.m_id_, &from._impl_.m_id_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.m_area_) -
    reinterpret_cast<char*>(&_impl_.m_id_)) + sizeof(_impl_.m_area_));
  // @@protoc_insertion_point(copy_constructor:pbdb.db_account)
}

inline void db_account::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.m_account_) {}

    , decltype(_impl_.m_passworld_) {}

    , decltype(_impl_.m_id_) { ::int64_t{0} }

    , decltype(_impl_.m_roleid_) { ::int64_t{0} }

    , decltype(_impl_.m_area_) { 0 }

  };
  _impl_.m_account_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.m_account_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.m_passworld_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.m_passworld_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

db_account::~db_account() {
  // @@protoc_insertion_point(destructor:pbdb.db_account)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void db_account::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.m_account_.Destroy();
  _impl_.m_passworld_.Destroy();
}

void db_account::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void db_account::Clear() {
// @@protoc_insertion_point(message_clear_start:pbdb.db_account)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.m_account_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.m_passworld_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&_impl_.m_id_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.m_area_) -
        reinterpret_cast<char*>(&_impl_.m_id_)) + sizeof(_impl_.m_area_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* db_account::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 m_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_m_id(&has_bits);
          _impl_.m_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 m_roleid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_m_roleid(&has_bits);
          _impl_.m_roleid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string m_account = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_m_account();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "pbdb.db_account.m_account"));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string m_passworld = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_m_passworld();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "pbdb.db_account.m_passworld"));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 m_area = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_m_area(&has_bits);
          _impl_.m_area_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* db_account::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pbdb.db_account)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 m_id = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        1, this->_internal_m_id(), target);
  }

  // optional int64 m_roleid = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        2, this->_internal_m_roleid(), target);
  }

  // optional string m_account = 3;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_m_account();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "pbdb.db_account.m_account");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // optional string m_passworld = 4;
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_m_passworld();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "pbdb.db_account.m_passworld");
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  // optional int32 m_area = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        5, this->_internal_m_area(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pbdb.db_account)
  return target;
}

::size_t db_account::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pbdb.db_account)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string m_account = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_m_account());
    }

    // optional string m_passworld = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_m_passworld());
    }

    // optional int64 m_id = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_m_id());
    }

    // optional int64 m_roleid = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_m_roleid());
    }

    // optional int32 m_area = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_m_area());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData db_account::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    db_account::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*db_account::GetClassData() const { return &_class_data_; }


void db_account::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<db_account*>(&to_msg);
  auto& from = static_cast<const db_account&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pbdb.db_account)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_m_account(from._internal_m_account());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_m_passworld(from._internal_m_passworld());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.m_id_ = from._impl_.m_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.m_roleid_ = from._impl_.m_roleid_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.m_area_ = from._impl_.m_area_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void db_account::CopyFrom(const db_account& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pbdb.db_account)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool db_account::IsInitialized() const {
  return true;
}

void db_account::InternalSwap(db_account* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.m_account_, lhs_arena,
                                       &other->_impl_.m_account_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.m_passworld_, lhs_arena,
                                       &other->_impl_.m_passworld_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(db_account, _impl_.m_area_)
      + sizeof(db_account::_impl_.m_area_)
      - PROTOBUF_FIELD_OFFSET(db_account, _impl_.m_id_)>(
          reinterpret_cast<char*>(&_impl_.m_id_),
          reinterpret_cast<char*>(&other->_impl_.m_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata db_account::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_db_2eproto_getter, &descriptor_table_db_2eproto_once,
      file_level_metadata_db_2eproto[0]);
}
// ===================================================================

class db_brief::_Internal {
 public:
  using HasBits = decltype(std::declval<db_brief>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(db_brief, _impl_._has_bits_);
  static void set_has_m_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_m_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_m_lv(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_m_moneygold(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_m_moneysilver(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

db_brief::db_brief(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pbdb.db_brief)
}
db_brief::db_brief(const db_brief& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  db_brief* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.m_name_) {}

    , decltype(_impl_.m_id_) {}

    , decltype(_impl_.m_lv_) {}

    , decltype(_impl_.m_moneygold_) {}

    , decltype(_impl_.m_moneysilver_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.m_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.m_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.m_name_.Set(from._internal_m_name(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.m_id_, &from._impl_.m_id_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.m_moneysilver_) -
    reinterpret_cast<char*>(&_impl_.m_id_)) + sizeof(_impl_.m_moneysilver_));
  // @@protoc_insertion_point(copy_constructor:pbdb.db_brief)
}

inline void db_brief::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.m_name_) {}

    , decltype(_impl_.m_id_) { ::int64_t{0} }

    , decltype(_impl_.m_lv_) { 0 }

    , decltype(_impl_.m_moneygold_) { 0 }

    , decltype(_impl_.m_moneysilver_) { 0 }

  };
  _impl_.m_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.m_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

db_brief::~db_brief() {
  // @@protoc_insertion_point(destructor:pbdb.db_brief)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void db_brief::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.m_name_.Destroy();
}

void db_brief::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void db_brief::Clear() {
// @@protoc_insertion_point(message_clear_start:pbdb.db_brief)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.m_name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&_impl_.m_id_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.m_moneysilver_) -
        reinterpret_cast<char*>(&_impl_.m_id_)) + sizeof(_impl_.m_moneysilver_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* db_brief::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 m_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_m_id(&has_bits);
          _impl_.m_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string m_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_m_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "pbdb.db_brief.m_name"));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 m_lv = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_m_lv(&has_bits);
          _impl_.m_lv_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 m_moneygold = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_m_moneygold(&has_bits);
          _impl_.m_moneygold_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 m_moneysilver = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_m_moneysilver(&has_bits);
          _impl_.m_moneysilver_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* db_brief::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pbdb.db_brief)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 m_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        1, this->_internal_m_id(), target);
  }

  // optional string m_name = 2;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_m_name();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "pbdb.db_brief.m_name");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // optional int32 m_lv = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        3, this->_internal_m_lv(), target);
  }

  // optional int32 m_moneygold = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        4, this->_internal_m_moneygold(), target);
  }

  // optional int32 m_moneysilver = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        5, this->_internal_m_moneysilver(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pbdb.db_brief)
  return target;
}

::size_t db_brief::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pbdb.db_brief)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string m_name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_m_name());
    }

    // optional int64 m_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_m_id());
    }

    // optional int32 m_lv = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_m_lv());
    }

    // optional int32 m_moneygold = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_m_moneygold());
    }

    // optional int32 m_moneysilver = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_m_moneysilver());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData db_brief::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    db_brief::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*db_brief::GetClassData() const { return &_class_data_; }


void db_brief::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<db_brief*>(&to_msg);
  auto& from = static_cast<const db_brief&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pbdb.db_brief)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_m_name(from._internal_m_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.m_id_ = from._impl_.m_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.m_lv_ = from._impl_.m_lv_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.m_moneygold_ = from._impl_.m_moneygold_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.m_moneysilver_ = from._impl_.m_moneysilver_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void db_brief::CopyFrom(const db_brief& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pbdb.db_brief)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool db_brief::IsInitialized() const {
  return true;
}

void db_brief::InternalSwap(db_brief* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.m_name_, lhs_arena,
                                       &other->_impl_.m_name_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(db_brief, _impl_.m_moneysilver_)
      + sizeof(db_brief::_impl_.m_moneysilver_)
      - PROTOBUF_FIELD_OFFSET(db_brief, _impl_.m_id_)>(
          reinterpret_cast<char*>(&_impl_.m_id_),
          reinterpret_cast<char*>(&other->_impl_.m_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata db_brief::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_db_2eproto_getter, &descriptor_table_db_2eproto_once,
      file_level_metadata_db_2eproto[1]);
}
// ===================================================================

class db_role::_Internal {
 public:
  using HasBits = decltype(std::declval<db_role>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(db_role, _impl_._has_bits_);
  static void set_has_m_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::pbdb::db_brief& m_base(const db_role* msg);
  static void set_has_m_base(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::pbdb::db_brief&
db_role::_Internal::m_base(const db_role* msg) {
  return *msg->_impl_.m_base_;
}
db_role::db_role(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pbdb.db_role)
}
db_role::db_role(const db_role& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  db_role* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.m_base_){nullptr}
    , decltype(_impl_.m_id_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.m_base_ = new ::pbdb::db_brief(*from._impl_.m_base_);
  }
  _this->_impl_.m_id_ = from._impl_.m_id_;
  // @@protoc_insertion_point(copy_constructor:pbdb.db_role)
}

inline void db_role::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.m_base_){nullptr}
    , decltype(_impl_.m_id_) { ::int64_t{0} }

  };
}

db_role::~db_role() {
  // @@protoc_insertion_point(destructor:pbdb.db_role)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void db_role::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.m_base_;
}

void db_role::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void db_role::Clear() {
// @@protoc_insertion_point(message_clear_start:pbdb.db_role)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.m_base_ != nullptr);
    _impl_.m_base_->Clear();
  }
  _impl_.m_id_ = ::int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* db_role::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 m_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_m_id(&has_bits);
          _impl_.m_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .pbdb.db_brief m_base = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_m_base(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* db_role::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pbdb.db_role)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 m_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        1, this->_internal_m_id(), target);
  }

  // optional .pbdb.db_brief m_base = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::m_base(this),
        _Internal::m_base(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pbdb.db_role)
  return target;
}

::size_t db_role::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pbdb.db_role)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .pbdb.db_brief m_base = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.m_base_);
    }

    // optional int64 m_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_m_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData db_role::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    db_role::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*db_role::GetClassData() const { return &_class_data_; }


void db_role::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<db_role*>(&to_msg);
  auto& from = static_cast<const db_role&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pbdb.db_role)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_m_base()->::pbdb::db_brief::MergeFrom(
          from._internal_m_base());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.m_id_ = from._impl_.m_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void db_role::CopyFrom(const db_role& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pbdb.db_role)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool db_role::IsInitialized() const {
  return true;
}

void db_role::InternalSwap(db_role* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(db_role, _impl_.m_id_)
      + sizeof(db_role::_impl_.m_id_)
      - PROTOBUF_FIELD_OFFSET(db_role, _impl_.m_base_)>(
          reinterpret_cast<char*>(&_impl_.m_base_),
          reinterpret_cast<char*>(&other->_impl_.m_base_));
}

::PROTOBUF_NAMESPACE_ID::Metadata db_role::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_db_2eproto_getter, &descriptor_table_db_2eproto_once,
      file_level_metadata_db_2eproto[2]);
}
// ===================================================================

class item::_Internal {
 public:
  using HasBits = decltype(std::declval<item>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(item, _impl_._has_bits_);
  static void set_has_m_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_m_tid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_m_count(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_m_lv(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_m_star(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

item::item(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pbdb.item)
}
item::item(const item& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:pbdb.item)
}

inline void item::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.m_id_) { 0 }

    , decltype(_impl_.m_tid_) { 0 }

    , decltype(_impl_.m_count_) { 0 }

    , decltype(_impl_.m_lv_) { 0 }

    , decltype(_impl_.m_star_) { 0 }

  };
}

item::~item() {
  // @@protoc_insertion_point(destructor:pbdb.item)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void item::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void item::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void item::Clear() {
// @@protoc_insertion_point(message_clear_start:pbdb.item)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.m_id_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.m_star_) -
        reinterpret_cast<char*>(&_impl_.m_id_)) + sizeof(_impl_.m_star_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* item::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 m_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_m_id(&has_bits);
          _impl_.m_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 m_tid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_m_tid(&has_bits);
          _impl_.m_tid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 m_count = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_m_count(&has_bits);
          _impl_.m_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 m_lv = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_m_lv(&has_bits);
          _impl_.m_lv_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 m_star = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_m_star(&has_bits);
          _impl_.m_star_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* item::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pbdb.item)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 m_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        1, this->_internal_m_id(), target);
  }

  // optional int32 m_tid = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        2, this->_internal_m_tid(), target);
  }

  // optional int32 m_count = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        3, this->_internal_m_count(), target);
  }

  // optional int32 m_lv = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        4, this->_internal_m_lv(), target);
  }

  // optional int32 m_star = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        5, this->_internal_m_star(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pbdb.item)
  return target;
}

::size_t item::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pbdb.item)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional int32 m_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_m_id());
    }

    // optional int32 m_tid = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_m_tid());
    }

    // optional int32 m_count = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_m_count());
    }

    // optional int32 m_lv = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_m_lv());
    }

    // optional int32 m_star = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_m_star());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData item::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    item::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*item::GetClassData() const { return &_class_data_; }


void item::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<item*>(&to_msg);
  auto& from = static_cast<const item&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pbdb.item)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.m_id_ = from._impl_.m_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.m_tid_ = from._impl_.m_tid_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.m_count_ = from._impl_.m_count_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.m_lv_ = from._impl_.m_lv_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.m_star_ = from._impl_.m_star_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void item::CopyFrom(const item& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pbdb.item)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool item::IsInitialized() const {
  return true;
}

void item::InternalSwap(item* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(item, _impl_.m_star_)
      + sizeof(item::_impl_.m_star_)
      - PROTOBUF_FIELD_OFFSET(item, _impl_.m_id_)>(
          reinterpret_cast<char*>(&_impl_.m_id_),
          reinterpret_cast<char*>(&other->_impl_.m_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata item::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_db_2eproto_getter, &descriptor_table_db_2eproto_once,
      file_level_metadata_db_2eproto[3]);
}
// ===================================================================

db_bag_MItemsEntry_DoNotUse::db_bag_MItemsEntry_DoNotUse() {}
db_bag_MItemsEntry_DoNotUse::db_bag_MItemsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void db_bag_MItemsEntry_DoNotUse::MergeFrom(const db_bag_MItemsEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata db_bag_MItemsEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_db_2eproto_getter, &descriptor_table_db_2eproto_once,
      file_level_metadata_db_2eproto[4]);
}
// ===================================================================

class db_bag::_Internal {
 public:
  using HasBits = decltype(std::declval<db_bag>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(db_bag, _impl_._has_bits_);
  static void set_has_m_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_m_maxid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

db_bag::db_bag(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pbdb.db_bag)
}
db_bag::db_bag(const db_bag& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  db_bag* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_.m_items_)*/{}
    , decltype(_impl_.m_id_) {}

    , decltype(_impl_.m_maxid_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.m_items_.MergeFrom(from._impl_.m_items_);
  ::memcpy(&_impl_.m_id_, &from._impl_.m_id_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.m_maxid_) -
    reinterpret_cast<char*>(&_impl_.m_id_)) + sizeof(_impl_.m_maxid_));
  // @@protoc_insertion_point(copy_constructor:pbdb.db_bag)
}

inline void db_bag::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_.m_items_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.m_id_) { ::int64_t{0} }

    , decltype(_impl_.m_maxid_) { 0 }

  };
}

db_bag::~db_bag() {
  // @@protoc_insertion_point(destructor:pbdb.db_bag)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void db_bag::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.m_items_.~MapField();
}

void db_bag::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void db_bag::Clear() {
// @@protoc_insertion_point(message_clear_start:pbdb.db_bag)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.m_items_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.m_id_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.m_maxid_) -
        reinterpret_cast<char*>(&_impl_.m_id_)) + sizeof(_impl_.m_maxid_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* db_bag::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 m_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_m_id(&has_bits);
          _impl_.m_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // map<int32, .pbdb.item> m_items = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.m_items_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 m_maxid = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_m_maxid(&has_bits);
          _impl_.m_maxid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* db_bag::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pbdb.db_bag)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 m_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        1, this->_internal_m_id(), target);
  }

  // map<int32, .pbdb.item> m_items = 2;
  if (!this->_internal_m_items().empty()) {
    using MapType = ::_pb::Map<::int32_t, ::pbdb::item>;
    using WireHelper = db_bag_MItemsEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_m_items();

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterFlat<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(2, entry.first, entry.second, target, stream);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(2, entry.first, entry.second, target, stream);
      }
    }
  }

  // optional int32 m_maxid = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        3, this->_internal_m_maxid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pbdb.db_bag)
  return target;
}

::size_t db_bag::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pbdb.db_bag)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<int32, .pbdb.item> m_items = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_m_items_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< ::int32_t, ::pbdb::item >::const_iterator
      it = this->_internal_m_items().begin();
      it != this->_internal_m_items().end(); ++it) {
    total_size += db_bag_MItemsEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int64 m_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_m_id());
    }

    // optional int32 m_maxid = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_m_maxid());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData db_bag::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    db_bag::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*db_bag::GetClassData() const { return &_class_data_; }


void db_bag::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<db_bag*>(&to_msg);
  auto& from = static_cast<const db_bag&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pbdb.db_bag)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.m_items_.MergeFrom(from._impl_.m_items_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.m_id_ = from._impl_.m_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.m_maxid_ = from._impl_.m_maxid_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void db_bag::CopyFrom(const db_bag& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pbdb.db_bag)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool db_bag::IsInitialized() const {
  return true;
}

void db_bag::InternalSwap(db_bag* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.m_items_.InternalSwap(&other->_impl_.m_items_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(db_bag, _impl_.m_maxid_)
      + sizeof(db_bag::_impl_.m_maxid_)
      - PROTOBUF_FIELD_OFFSET(db_bag, _impl_.m_id_)>(
          reinterpret_cast<char*>(&_impl_.m_id_),
          reinterpret_cast<char*>(&other->_impl_.m_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata db_bag::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_db_2eproto_getter, &descriptor_table_db_2eproto_once,
      file_level_metadata_db_2eproto[5]);
}
// ===================================================================

class db_keyvalue::_Internal {
 public:
  using HasBits = decltype(std::declval<db_keyvalue>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(db_keyvalue, _impl_._has_bits_);
  static void set_has_m_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_m_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_m_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

db_keyvalue::db_keyvalue(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pbdb.db_keyvalue)
}
db_keyvalue::db_keyvalue(const db_keyvalue& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  db_keyvalue* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.m_key_) {}

    , decltype(_impl_.m_value_) {}

    , decltype(_impl_.m_id_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.m_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.m_key_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.m_key_.Set(from._internal_m_key(), _this->GetArenaForAllocation());
  }
  _impl_.m_value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.m_value_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.m_value_.Set(from._internal_m_value(), _this->GetArenaForAllocation());
  }
  _this->_impl_.m_id_ = from._impl_.m_id_;
  // @@protoc_insertion_point(copy_constructor:pbdb.db_keyvalue)
}

inline void db_keyvalue::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.m_key_) {}

    , decltype(_impl_.m_value_) {}

    , decltype(_impl_.m_id_) { ::int64_t{0} }

  };
  _impl_.m_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.m_key_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.m_value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.m_value_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

db_keyvalue::~db_keyvalue() {
  // @@protoc_insertion_point(destructor:pbdb.db_keyvalue)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void db_keyvalue::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.m_key_.Destroy();
  _impl_.m_value_.Destroy();
}

void db_keyvalue::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void db_keyvalue::Clear() {
// @@protoc_insertion_point(message_clear_start:pbdb.db_keyvalue)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.m_key_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.m_value_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.m_id_ = ::int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* db_keyvalue::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 m_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_m_id(&has_bits);
          _impl_.m_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string m_key = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_m_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "pbdb.db_keyvalue.m_key"));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string m_value = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_m_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "pbdb.db_keyvalue.m_value"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* db_keyvalue::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pbdb.db_keyvalue)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 m_id = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        1, this->_internal_m_id(), target);
  }

  // optional string m_key = 2;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_m_key();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "pbdb.db_keyvalue.m_key");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // optional string m_value = 3;
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_m_value();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "pbdb.db_keyvalue.m_value");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pbdb.db_keyvalue)
  return target;
}

::size_t db_keyvalue::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pbdb.db_keyvalue)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string m_key = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_m_key());
    }

    // optional string m_value = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_m_value());
    }

    // optional int64 m_id = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_m_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData db_keyvalue::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    db_keyvalue::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*db_keyvalue::GetClassData() const { return &_class_data_; }


void db_keyvalue::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<db_keyvalue*>(&to_msg);
  auto& from = static_cast<const db_keyvalue&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pbdb.db_keyvalue)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_m_key(from._internal_m_key());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_m_value(from._internal_m_value());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.m_id_ = from._impl_.m_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void db_keyvalue::CopyFrom(const db_keyvalue& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pbdb.db_keyvalue)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool db_keyvalue::IsInitialized() const {
  return true;
}

void db_keyvalue::InternalSwap(db_keyvalue* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.m_key_, lhs_arena,
                                       &other->_impl_.m_key_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.m_value_, lhs_arena,
                                       &other->_impl_.m_value_, rhs_arena);

  swap(_impl_.m_id_, other->_impl_.m_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata db_keyvalue::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_db_2eproto_getter, &descriptor_table_db_2eproto_once,
      file_level_metadata_db_2eproto[6]);
}
// ===================================================================

class mailitem::_Internal {
 public:
  using HasBits = decltype(std::declval<mailitem>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(mailitem, _impl_._has_bits_);
  static void set_has_m_itemtid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_m_count(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

mailitem::mailitem(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pbdb.mailitem)
}
mailitem::mailitem(const mailitem& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:pbdb.mailitem)
}

inline void mailitem::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.m_itemtid_) { 0 }

    , decltype(_impl_.m_count_) { 0 }

  };
}

mailitem::~mailitem() {
  // @@protoc_insertion_point(destructor:pbdb.mailitem)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void mailitem::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void mailitem::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void mailitem::Clear() {
// @@protoc_insertion_point(message_clear_start:pbdb.mailitem)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.m_itemtid_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.m_count_) -
        reinterpret_cast<char*>(&_impl_.m_itemtid_)) + sizeof(_impl_.m_count_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* mailitem::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 m_itemtid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_m_itemtid(&has_bits);
          _impl_.m_itemtid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 m_count = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_m_count(&has_bits);
          _impl_.m_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* mailitem::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pbdb.mailitem)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 m_itemtid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        1, this->_internal_m_itemtid(), target);
  }

  // optional int32 m_count = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        2, this->_internal_m_count(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pbdb.mailitem)
  return target;
}

::size_t mailitem::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pbdb.mailitem)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int32 m_itemtid = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_m_itemtid());
    }

    // optional int32 m_count = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_m_count());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData mailitem::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    mailitem::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*mailitem::GetClassData() const { return &_class_data_; }


void mailitem::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<mailitem*>(&to_msg);
  auto& from = static_cast<const mailitem&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pbdb.mailitem)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.m_itemtid_ = from._impl_.m_itemtid_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.m_count_ = from._impl_.m_count_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void mailitem::CopyFrom(const mailitem& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pbdb.mailitem)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool mailitem::IsInitialized() const {
  return true;
}

void mailitem::InternalSwap(mailitem* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(mailitem, _impl_.m_count_)
      + sizeof(mailitem::_impl_.m_count_)
      - PROTOBUF_FIELD_OFFSET(mailitem, _impl_.m_itemtid_)>(
          reinterpret_cast<char*>(&_impl_.m_itemtid_),
          reinterpret_cast<char*>(&other->_impl_.m_itemtid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata mailitem::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_db_2eproto_getter, &descriptor_table_db_2eproto_once,
      file_level_metadata_db_2eproto[7]);
}
// ===================================================================

class mail::_Internal {
 public:
  using HasBits = decltype(std::declval<mail>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(mail, _impl_._has_bits_);
  static void set_has_m_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_m_createutc(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_m_tid(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_m_prams(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_m_read(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_m_draw(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

mail::mail(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pbdb.mail)
}
mail::mail(const mail& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  mail* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.m_items_){from._impl_.m_items_}
    , decltype(_impl_.m_prams_) {}

    , decltype(_impl_.m_id_) {}

    , decltype(_impl_.m_createutc_) {}

    , decltype(_impl_.m_tid_) {}

    , decltype(_impl_.m_read_) {}

    , decltype(_impl_.m_draw_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.m_prams_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.m_prams_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.m_prams_.Set(from._internal_m_prams(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.m_id_, &from._impl_.m_id_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.m_draw_) -
    reinterpret_cast<char*>(&_impl_.m_id_)) + sizeof(_impl_.m_draw_));
  // @@protoc_insertion_point(copy_constructor:pbdb.mail)
}

inline void mail::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.m_items_){arena}
    , decltype(_impl_.m_prams_) {}

    , decltype(_impl_.m_id_) { 0 }

    , decltype(_impl_.m_createutc_) { 0 }

    , decltype(_impl_.m_tid_) { 0 }

    , decltype(_impl_.m_read_) { false }

    , decltype(_impl_.m_draw_) { false }

  };
  _impl_.m_prams_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.m_prams_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

mail::~mail() {
  // @@protoc_insertion_point(destructor:pbdb.mail)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void mail::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_m_items()->~RepeatedPtrField();
  _impl_.m_prams_.Destroy();
}

void mail::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void mail::Clear() {
// @@protoc_insertion_point(message_clear_start:pbdb.mail)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_m_items()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.m_prams_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000003eu) {
    ::memset(&_impl_.m_id_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.m_draw_) -
        reinterpret_cast<char*>(&_impl_.m_id_)) + sizeof(_impl_.m_draw_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* mail::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 m_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_m_id(&has_bits);
          _impl_.m_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 m_createutc = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_m_createutc(&has_bits);
          _impl_.m_createutc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 m_tid = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_m_tid(&has_bits);
          _impl_.m_tid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string m_prams = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_m_prams();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "pbdb.mail.m_prams"));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .pbdb.mailitem m_items = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_m_items(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional bool m_read = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _Internal::set_has_m_read(&has_bits);
          _impl_.m_read_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional bool m_draw = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          _Internal::set_has_m_draw(&has_bits);
          _impl_.m_draw_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* mail::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pbdb.mail)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 m_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        1, this->_internal_m_id(), target);
  }

  // optional int32 m_createutc = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        2, this->_internal_m_createutc(), target);
  }

  // optional int32 m_tid = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        3, this->_internal_m_tid(), target);
  }

  // optional string m_prams = 4;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_m_prams();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "pbdb.mail.m_prams");
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  // repeated .pbdb.mailitem m_items = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_m_items_size()); i < n; i++) {
    const auto& repfield = this->_internal_m_items(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bool m_read = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        6, this->_internal_m_read(), target);
  }

  // optional bool m_draw = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        7, this->_internal_m_draw(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pbdb.mail)
  return target;
}

::size_t mail::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pbdb.mail)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .pbdb.mailitem m_items = 5;
  total_size += 1UL * this->_internal_m_items_size();
  for (const auto& msg : this->_internal_m_items()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string m_prams = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_m_prams());
    }

    // optional int32 m_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_m_id());
    }

    // optional int32 m_createutc = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_m_createutc());
    }

    // optional int32 m_tid = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_m_tid());
    }

    // optional bool m_read = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2;
    }

    // optional bool m_draw = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData mail::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    mail::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*mail::GetClassData() const { return &_class_data_; }


void mail::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<mail*>(&to_msg);
  auto& from = static_cast<const mail&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pbdb.mail)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_m_items()->MergeFrom(from._internal_m_items());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_m_prams(from._internal_m_prams());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.m_id_ = from._impl_.m_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.m_createutc_ = from._impl_.m_createutc_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.m_tid_ = from._impl_.m_tid_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.m_read_ = from._impl_.m_read_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.m_draw_ = from._impl_.m_draw_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void mail::CopyFrom(const mail& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pbdb.mail)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool mail::IsInitialized() const {
  return true;
}

void mail::InternalSwap(mail* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _internal_mutable_m_items()->InternalSwap(other->_internal_mutable_m_items());
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.m_prams_, lhs_arena,
                                       &other->_impl_.m_prams_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(mail, _impl_.m_draw_)
      + sizeof(mail::_impl_.m_draw_)
      - PROTOBUF_FIELD_OFFSET(mail, _impl_.m_id_)>(
          reinterpret_cast<char*>(&_impl_.m_id_),
          reinterpret_cast<char*>(&other->_impl_.m_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata mail::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_db_2eproto_getter, &descriptor_table_db_2eproto_once,
      file_level_metadata_db_2eproto[8]);
}
// ===================================================================

db_mail_MMailEntry_DoNotUse::db_mail_MMailEntry_DoNotUse() {}
db_mail_MMailEntry_DoNotUse::db_mail_MMailEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void db_mail_MMailEntry_DoNotUse::MergeFrom(const db_mail_MMailEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata db_mail_MMailEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_db_2eproto_getter, &descriptor_table_db_2eproto_once,
      file_level_metadata_db_2eproto[9]);
}
// ===================================================================

class db_mail::_Internal {
 public:
  using HasBits = decltype(std::declval<db_mail>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(db_mail, _impl_._has_bits_);
  static void set_has_m_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

db_mail::db_mail(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pbdb.db_mail)
}
db_mail::db_mail(const db_mail& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  db_mail* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_.m_mail_)*/{}
    , decltype(_impl_.m_id_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.m_mail_.MergeFrom(from._impl_.m_mail_);
  _this->_impl_.m_id_ = from._impl_.m_id_;
  // @@protoc_insertion_point(copy_constructor:pbdb.db_mail)
}

inline void db_mail::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_.m_mail_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.m_id_) { ::int64_t{0} }

  };
}

db_mail::~db_mail() {
  // @@protoc_insertion_point(destructor:pbdb.db_mail)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void db_mail::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.m_mail_.~MapField();
}

void db_mail::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void db_mail::Clear() {
// @@protoc_insertion_point(message_clear_start:pbdb.db_mail)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.m_mail_.Clear();
  _impl_.m_id_ = ::int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* db_mail::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 m_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_m_id(&has_bits);
          _impl_.m_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // map<int32, .pbdb.mail> m_mail = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.m_mail_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* db_mail::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pbdb.db_mail)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 m_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        1, this->_internal_m_id(), target);
  }

  // map<int32, .pbdb.mail> m_mail = 2;
  if (!this->_internal_m_mail().empty()) {
    using MapType = ::_pb::Map<::int32_t, ::pbdb::mail>;
    using WireHelper = db_mail_MMailEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_m_mail();

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterFlat<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(2, entry.first, entry.second, target, stream);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(2, entry.first, entry.second, target, stream);
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pbdb.db_mail)
  return target;
}

::size_t db_mail::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pbdb.db_mail)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<int32, .pbdb.mail> m_mail = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_m_mail_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< ::int32_t, ::pbdb::mail >::const_iterator
      it = this->_internal_m_mail().begin();
      it != this->_internal_m_mail().end(); ++it) {
    total_size += db_mail_MMailEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // optional int64 m_id = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_m_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData db_mail::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    db_mail::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*db_mail::GetClassData() const { return &_class_data_; }


void db_mail::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<db_mail*>(&to_msg);
  auto& from = static_cast<const db_mail&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pbdb.db_mail)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.m_mail_.MergeFrom(from._impl_.m_mail_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_set_m_id(from._internal_m_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void db_mail::CopyFrom(const db_mail& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pbdb.db_mail)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool db_mail::IsInitialized() const {
  return true;
}

void db_mail::InternalSwap(db_mail* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.m_mail_.InternalSwap(&other->_impl_.m_mail_);

  swap(_impl_.m_id_, other->_impl_.m_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata db_mail::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_db_2eproto_getter, &descriptor_table_db_2eproto_once,
      file_level_metadata_db_2eproto[10]);
}
// ===================================================================

class db_guild::_Internal {
 public:
  using HasBits = decltype(std::declval<db_guild>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(db_guild, _impl_._has_bits_);
  static void set_has_m_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_m_guild(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_m_leader(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

db_guild::db_guild(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pbdb.db_guild)
}
db_guild::db_guild(const db_guild& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  db_guild* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.m_members_) { from._impl_.m_members_ }
    ,/* _impl_._m_members_cached_byte_size_ = */ { 0 }

    , decltype(_impl_.m_guild_) {}

    , decltype(_impl_.m_id_) {}

    , decltype(_impl_.m_leader_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.m_guild_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.m_guild_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.m_guild_.Set(from._internal_m_guild(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.m_id_, &from._impl_.m_id_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.m_leader_) -
    reinterpret_cast<char*>(&_impl_.m_id_)) + sizeof(_impl_.m_leader_));
  // @@protoc_insertion_point(copy_constructor:pbdb.db_guild)
}

inline void db_guild::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.m_members_) { arena }
    ,/* _impl_._m_members_cached_byte_size_ = */ { 0 }

    , decltype(_impl_.m_guild_) {}

    , decltype(_impl_.m_id_) { ::int64_t{0} }

    , decltype(_impl_.m_leader_) { ::int64_t{0} }

  };
  _impl_.m_guild_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.m_guild_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

db_guild::~db_guild() {
  // @@protoc_insertion_point(destructor:pbdb.db_guild)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void db_guild::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.m_members_.~RepeatedField();
  _impl_.m_guild_.Destroy();
}

void db_guild::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void db_guild::Clear() {
// @@protoc_insertion_point(message_clear_start:pbdb.db_guild)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_m_members()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.m_guild_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.m_id_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.m_leader_) -
        reinterpret_cast<char*>(&_impl_.m_id_)) + sizeof(_impl_.m_leader_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* db_guild::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 m_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_m_id(&has_bits);
          _impl_.m_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string m_guild = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_m_guild();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "pbdb.db_guild.m_guild"));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 m_leader = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_m_leader(&has_bits);
          _impl_.m_leader_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated int64 m_members = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_m_members(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<::uint8_t>(tag) == 32) {
          _internal_add_m_members(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* db_guild::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pbdb.db_guild)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 m_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        1, this->_internal_m_id(), target);
  }

  // optional string m_guild = 2;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_m_guild();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "pbdb.db_guild.m_guild");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // optional int64 m_leader = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        3, this->_internal_m_leader(), target);
  }

  // repeated int64 m_members = 4;
  {
    int byte_size = _impl_._m_members_cached_byte_size_.Get();
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(4, _internal_m_members(),
                                                 byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pbdb.db_guild)
  return target;
}

::size_t db_guild::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pbdb.db_guild)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int64 m_members = 4;
  {
    std::size_t data_size = ::_pbi::WireFormatLite::Int64Size(
        this->_internal_m_members())
    ;
    _impl_._m_members_cached_byte_size_.Set(::_pbi::ToCachedSize(data_size));
    std::size_t tag_size = data_size == 0
        ? 0
        : 1 + ::_pbi::WireFormatLite::Int32Size(
                            static_cast<int32_t>(data_size))
    ;
    total_size += tag_size + data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string m_guild = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_m_guild());
    }

    // optional int64 m_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_m_id());
    }

    // optional int64 m_leader = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_m_leader());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData db_guild::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    db_guild::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*db_guild::GetClassData() const { return &_class_data_; }


void db_guild::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<db_guild*>(&to_msg);
  auto& from = static_cast<const db_guild&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pbdb.db_guild)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.m_members_.MergeFrom(from._impl_.m_members_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_m_guild(from._internal_m_guild());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.m_id_ = from._impl_.m_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.m_leader_ = from._impl_.m_leader_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void db_guild::CopyFrom(const db_guild& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pbdb.db_guild)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool db_guild::IsInitialized() const {
  return true;
}

void db_guild::InternalSwap(db_guild* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.m_members_.InternalSwap(&other->_impl_.m_members_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.m_guild_, lhs_arena,
                                       &other->_impl_.m_guild_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(db_guild, _impl_.m_leader_)
      + sizeof(db_guild::_impl_.m_leader_)
      - PROTOBUF_FIELD_OFFSET(db_guild, _impl_.m_id_)>(
          reinterpret_cast<char*>(&_impl_.m_id_),
          reinterpret_cast<char*>(&other->_impl_.m_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata db_guild::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_db_2eproto_getter, &descriptor_table_db_2eproto_once,
      file_level_metadata_db_2eproto[11]);
}
// ===================================================================

class db_notice::_Internal {
 public:
  using HasBits = decltype(std::declval<db_notice>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(db_notice, _impl_._has_bits_);
  static void set_has_m_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_m_notice(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_m_starttime(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_m_finishtime(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

db_notice::db_notice(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pbdb.db_notice)
}
db_notice::db_notice(const db_notice& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  db_notice* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.m_notice_) {}

    , decltype(_impl_.m_id_) {}

    , decltype(_impl_.m_starttime_) {}

    , decltype(_impl_.m_finishtime_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.m_notice_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.m_notice_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.m_notice_.Set(from._internal_m_notice(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.m_id_, &from._impl_.m_id_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.m_finishtime_) -
    reinterpret_cast<char*>(&_impl_.m_id_)) + sizeof(_impl_.m_finishtime_));
  // @@protoc_insertion_point(copy_constructor:pbdb.db_notice)
}

inline void db_notice::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.m_notice_) {}

    , decltype(_impl_.m_id_) { ::int64_t{0} }

    , decltype(_impl_.m_starttime_) { 0 }

    , decltype(_impl_.m_finishtime_) { 0 }

  };
  _impl_.m_notice_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.m_notice_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

db_notice::~db_notice() {
  // @@protoc_insertion_point(destructor:pbdb.db_notice)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void db_notice::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.m_notice_.Destroy();
}

void db_notice::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void db_notice::Clear() {
// @@protoc_insertion_point(message_clear_start:pbdb.db_notice)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.m_notice_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.m_id_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.m_finishtime_) -
        reinterpret_cast<char*>(&_impl_.m_id_)) + sizeof(_impl_.m_finishtime_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* db_notice::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 m_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_m_id(&has_bits);
          _impl_.m_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string m_notice = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_m_notice();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "pbdb.db_notice.m_notice"));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 m_starttime = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_m_starttime(&has_bits);
          _impl_.m_starttime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 m_finishtime = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_m_finishtime(&has_bits);
          _impl_.m_finishtime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* db_notice::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pbdb.db_notice)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 m_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        1, this->_internal_m_id(), target);
  }

  // optional string m_notice = 2;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_m_notice();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "pbdb.db_notice.m_notice");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // optional int32 m_starttime = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        3, this->_internal_m_starttime(), target);
  }

  // optional int32 m_finishtime = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        4, this->_internal_m_finishtime(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pbdb.db_notice)
  return target;
}

::size_t db_notice::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pbdb.db_notice)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string m_notice = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_m_notice());
    }

    // optional int64 m_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_m_id());
    }

    // optional int32 m_starttime = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_m_starttime());
    }

    // optional int32 m_finishtime = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_m_finishtime());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData db_notice::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    db_notice::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*db_notice::GetClassData() const { return &_class_data_; }


void db_notice::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<db_notice*>(&to_msg);
  auto& from = static_cast<const db_notice&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pbdb.db_notice)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_m_notice(from._internal_m_notice());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.m_id_ = from._impl_.m_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.m_starttime_ = from._impl_.m_starttime_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.m_finishtime_ = from._impl_.m_finishtime_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void db_notice::CopyFrom(const db_notice& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pbdb.db_notice)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool db_notice::IsInitialized() const {
  return true;
}

void db_notice::InternalSwap(db_notice* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.m_notice_, lhs_arena,
                                       &other->_impl_.m_notice_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(db_notice, _impl_.m_finishtime_)
      + sizeof(db_notice::_impl_.m_finishtime_)
      - PROTOBUF_FIELD_OFFSET(db_notice, _impl_.m_id_)>(
          reinterpret_cast<char*>(&_impl_.m_id_),
          reinterpret_cast<char*>(&other->_impl_.m_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata db_notice::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_db_2eproto_getter, &descriptor_table_db_2eproto_once,
      file_level_metadata_db_2eproto[12]);
}
// ===================================================================

class rankitem::_Internal {
 public:
  using HasBits = decltype(std::declval<rankitem>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(rankitem, _impl_._has_bits_);
  static void set_has_m_roleid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_m_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_m_lv(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_m_lvtime(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

rankitem::rankitem(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pbdb.rankitem)
}
rankitem::rankitem(const rankitem& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  rankitem* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.m_name_) {}

    , decltype(_impl_.m_roleid_) {}

    , decltype(_impl_.m_lv_) {}

    , decltype(_impl_.m_lvtime_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.m_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.m_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.m_name_.Set(from._internal_m_name(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.m_roleid_, &from._impl_.m_roleid_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.m_lvtime_) -
    reinterpret_cast<char*>(&_impl_.m_roleid_)) + sizeof(_impl_.m_lvtime_));
  // @@protoc_insertion_point(copy_constructor:pbdb.rankitem)
}

inline void rankitem::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.m_name_) {}

    , decltype(_impl_.m_roleid_) { ::int64_t{0} }

    , decltype(_impl_.m_lv_) { 0 }

    , decltype(_impl_.m_lvtime_) { 0 }

  };
  _impl_.m_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.m_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

rankitem::~rankitem() {
  // @@protoc_insertion_point(destructor:pbdb.rankitem)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void rankitem::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.m_name_.Destroy();
}

void rankitem::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void rankitem::Clear() {
// @@protoc_insertion_point(message_clear_start:pbdb.rankitem)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.m_name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.m_roleid_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.m_lvtime_) -
        reinterpret_cast<char*>(&_impl_.m_roleid_)) + sizeof(_impl_.m_lvtime_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* rankitem::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 m_roleid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_m_roleid(&has_bits);
          _impl_.m_roleid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string m_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_m_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "pbdb.rankitem.m_name"));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 m_lv = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_m_lv(&has_bits);
          _impl_.m_lv_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 m_lvtime = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_m_lvtime(&has_bits);
          _impl_.m_lvtime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* rankitem::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pbdb.rankitem)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 m_roleid = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        1, this->_internal_m_roleid(), target);
  }

  // optional string m_name = 2;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_m_name();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "pbdb.rankitem.m_name");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // optional int32 m_lv = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        3, this->_internal_m_lv(), target);
  }

  // optional int32 m_lvtime = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        4, this->_internal_m_lvtime(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pbdb.rankitem)
  return target;
}

::size_t rankitem::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pbdb.rankitem)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string m_name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_m_name());
    }

    // optional int64 m_roleid = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_m_roleid());
    }

    // optional int32 m_lv = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_m_lv());
    }

    // optional int32 m_lvtime = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_m_lvtime());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData rankitem::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    rankitem::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*rankitem::GetClassData() const { return &_class_data_; }


void rankitem::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<rankitem*>(&to_msg);
  auto& from = static_cast<const rankitem&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pbdb.rankitem)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_m_name(from._internal_m_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.m_roleid_ = from._impl_.m_roleid_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.m_lv_ = from._impl_.m_lv_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.m_lvtime_ = from._impl_.m_lvtime_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void rankitem::CopyFrom(const rankitem& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pbdb.rankitem)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool rankitem::IsInitialized() const {
  return true;
}

void rankitem::InternalSwap(rankitem* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.m_name_, lhs_arena,
                                       &other->_impl_.m_name_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(rankitem, _impl_.m_lvtime_)
      + sizeof(rankitem::_impl_.m_lvtime_)
      - PROTOBUF_FIELD_OFFSET(rankitem, _impl_.m_roleid_)>(
          reinterpret_cast<char*>(&_impl_.m_roleid_),
          reinterpret_cast<char*>(&other->_impl_.m_roleid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata rankitem::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_db_2eproto_getter, &descriptor_table_db_2eproto_once,
      file_level_metadata_db_2eproto[13]);
}
// ===================================================================

db_ranklist_MItemEntry_DoNotUse::db_ranklist_MItemEntry_DoNotUse() {}
db_ranklist_MItemEntry_DoNotUse::db_ranklist_MItemEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void db_ranklist_MItemEntry_DoNotUse::MergeFrom(const db_ranklist_MItemEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata db_ranklist_MItemEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_db_2eproto_getter, &descriptor_table_db_2eproto_once,
      file_level_metadata_db_2eproto[14]);
}
// ===================================================================

class db_ranklist::_Internal {
 public:
  using HasBits = decltype(std::declval<db_ranklist>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(db_ranklist, _impl_._has_bits_);
  static void set_has_m_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

db_ranklist::db_ranklist(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pbdb.db_ranklist)
}
db_ranklist::db_ranklist(const db_ranklist& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  db_ranklist* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_.m_item_)*/{}
    , decltype(_impl_.m_id_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.m_item_.MergeFrom(from._impl_.m_item_);
  _this->_impl_.m_id_ = from._impl_.m_id_;
  // @@protoc_insertion_point(copy_constructor:pbdb.db_ranklist)
}

inline void db_ranklist::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_.m_item_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.m_id_) { ::int64_t{0} }

  };
}

db_ranklist::~db_ranklist() {
  // @@protoc_insertion_point(destructor:pbdb.db_ranklist)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void db_ranklist::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.m_item_.~MapField();
}

void db_ranklist::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void db_ranklist::Clear() {
// @@protoc_insertion_point(message_clear_start:pbdb.db_ranklist)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.m_item_.Clear();
  _impl_.m_id_ = ::int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* db_ranklist::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 m_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_m_id(&has_bits);
          _impl_.m_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // map<int64, .pbdb.rankitem> m_item = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.m_item_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* db_ranklist::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pbdb.db_ranklist)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 m_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        1, this->_internal_m_id(), target);
  }

  // map<int64, .pbdb.rankitem> m_item = 2;
  if (!this->_internal_m_item().empty()) {
    using MapType = ::_pb::Map<::int64_t, ::pbdb::rankitem>;
    using WireHelper = db_ranklist_MItemEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_m_item();

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterFlat<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(2, entry.first, entry.second, target, stream);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(2, entry.first, entry.second, target, stream);
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pbdb.db_ranklist)
  return target;
}

::size_t db_ranklist::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pbdb.db_ranklist)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<int64, .pbdb.rankitem> m_item = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_m_item_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< ::int64_t, ::pbdb::rankitem >::const_iterator
      it = this->_internal_m_item().begin();
      it != this->_internal_m_item().end(); ++it) {
    total_size += db_ranklist_MItemEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // optional int64 m_id = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_m_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData db_ranklist::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    db_ranklist::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*db_ranklist::GetClassData() const { return &_class_data_; }


void db_ranklist::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<db_ranklist*>(&to_msg);
  auto& from = static_cast<const db_ranklist&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pbdb.db_ranklist)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.m_item_.MergeFrom(from._impl_.m_item_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_set_m_id(from._internal_m_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void db_ranklist::CopyFrom(const db_ranklist& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pbdb.db_ranklist)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool db_ranklist::IsInitialized() const {
  return true;
}

void db_ranklist::InternalSwap(db_ranklist* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.m_item_.InternalSwap(&other->_impl_.m_item_);

  swap(_impl_.m_id_, other->_impl_.m_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata db_ranklist::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_db_2eproto_getter, &descriptor_table_db_2eproto_once,
      file_level_metadata_db_2eproto[15]);
}
// ===================================================================

class db_activity_data_drawcompliance::_Internal {
 public:
  using HasBits = decltype(std::declval<db_activity_data_drawcompliance>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(db_activity_data_drawcompliance, _impl_._has_bits_);
  static void set_has_m_count(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

db_activity_data_drawcompliance::db_activity_data_drawcompliance(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pbdb.db_activity.data.drawcompliance)
}
db_activity_data_drawcompliance::db_activity_data_drawcompliance(const db_activity_data_drawcompliance& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  db_activity_data_drawcompliance* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.m_reward_) { from._impl_.m_reward_ }
    ,/* _impl_._m_reward_cached_byte_size_ = */ { 0 }

    , decltype(_impl_.m_count_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.m_count_ = from._impl_.m_count_;
  // @@protoc_insertion_point(copy_constructor:pbdb.db_activity.data.drawcompliance)
}

inline void db_activity_data_drawcompliance::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.m_reward_) { arena }
    ,/* _impl_._m_reward_cached_byte_size_ = */ { 0 }

    , decltype(_impl_.m_count_) { 0 }

  };
}

db_activity_data_drawcompliance::~db_activity_data_drawcompliance() {
  // @@protoc_insertion_point(destructor:pbdb.db_activity.data.drawcompliance)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void db_activity_data_drawcompliance::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.m_reward_.~RepeatedField();
}

void db_activity_data_drawcompliance::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void db_activity_data_drawcompliance::Clear() {
// @@protoc_insertion_point(message_clear_start:pbdb.db_activity.data.drawcompliance)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_m_reward()->Clear();
  _impl_.m_count_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* db_activity_data_drawcompliance::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 m_count = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_m_count(&has_bits);
          _impl_.m_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated int32 m_reward = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_m_reward(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<::uint8_t>(tag) == 16) {
          _internal_add_m_reward(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* db_activity_data_drawcompliance::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pbdb.db_activity.data.drawcompliance)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 m_count = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        1, this->_internal_m_count(), target);
  }

  // repeated int32 m_reward = 2;
  {
    int byte_size = _impl_._m_reward_cached_byte_size_.Get();
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(2, _internal_m_reward(),
                                                 byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pbdb.db_activity.data.drawcompliance)
  return target;
}

::size_t db_activity_data_drawcompliance::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pbdb.db_activity.data.drawcompliance)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 m_reward = 2;
  {
    std::size_t data_size = ::_pbi::WireFormatLite::Int32Size(
        this->_internal_m_reward())
    ;
    _impl_._m_reward_cached_byte_size_.Set(::_pbi::ToCachedSize(data_size));
    std::size_t tag_size = data_size == 0
        ? 0
        : 1 + ::_pbi::WireFormatLite::Int32Size(
                            static_cast<int32_t>(data_size))
    ;
    total_size += tag_size + data_size;
  }

  // optional int32 m_count = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_m_count());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData db_activity_data_drawcompliance::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    db_activity_data_drawcompliance::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*db_activity_data_drawcompliance::GetClassData() const { return &_class_data_; }


void db_activity_data_drawcompliance::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<db_activity_data_drawcompliance*>(&to_msg);
  auto& from = static_cast<const db_activity_data_drawcompliance&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pbdb.db_activity.data.drawcompliance)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.m_reward_.MergeFrom(from._impl_.m_reward_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_set_m_count(from._internal_m_count());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void db_activity_data_drawcompliance::CopyFrom(const db_activity_data_drawcompliance& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pbdb.db_activity.data.drawcompliance)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool db_activity_data_drawcompliance::IsInitialized() const {
  return true;
}

void db_activity_data_drawcompliance::InternalSwap(db_activity_data_drawcompliance* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.m_reward_.InternalSwap(&other->_impl_.m_reward_);

  swap(_impl_.m_count_, other->_impl_.m_count_);
}

::PROTOBUF_NAMESPACE_ID::Metadata db_activity_data_drawcompliance::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_db_2eproto_getter, &descriptor_table_db_2eproto_once,
      file_level_metadata_db_2eproto[16]);
}
// ===================================================================

db_activity_data_MDrawcomplianceEntry_DoNotUse::db_activity_data_MDrawcomplianceEntry_DoNotUse() {}
db_activity_data_MDrawcomplianceEntry_DoNotUse::db_activity_data_MDrawcomplianceEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void db_activity_data_MDrawcomplianceEntry_DoNotUse::MergeFrom(const db_activity_data_MDrawcomplianceEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata db_activity_data_MDrawcomplianceEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_db_2eproto_getter, &descriptor_table_db_2eproto_once,
      file_level_metadata_db_2eproto[17]);
}
// ===================================================================

class db_activity_data::_Internal {
 public:
  using HasBits = decltype(std::declval<db_activity_data>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(db_activity_data, _impl_._has_bits_);
  static void set_has_m_beg(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_m_end(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_m_start(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_m_finish(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

db_activity_data::db_activity_data(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pbdb.db_activity.data)
}
db_activity_data::db_activity_data(const db_activity_data& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  db_activity_data* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_.m_drawcompliance_)*/{}
    , decltype(_impl_.m_beg_) {}

    , decltype(_impl_.m_end_) {}

    , decltype(_impl_.m_start_) {}

    , decltype(_impl_.m_finish_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.m_drawcompliance_.MergeFrom(from._impl_.m_drawcompliance_);
  ::memcpy(&_impl_.m_beg_, &from._impl_.m_beg_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.m_finish_) -
    reinterpret_cast<char*>(&_impl_.m_beg_)) + sizeof(_impl_.m_finish_));
  // @@protoc_insertion_point(copy_constructor:pbdb.db_activity.data)
}

inline void db_activity_data::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_.m_drawcompliance_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.m_beg_) { 0 }

    , decltype(_impl_.m_end_) { 0 }

    , decltype(_impl_.m_start_) { false }

    , decltype(_impl_.m_finish_) { false }

  };
}

db_activity_data::~db_activity_data() {
  // @@protoc_insertion_point(destructor:pbdb.db_activity.data)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void db_activity_data::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.m_drawcompliance_.~MapField();
}

void db_activity_data::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void db_activity_data::Clear() {
// @@protoc_insertion_point(message_clear_start:pbdb.db_activity.data)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.m_drawcompliance_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.m_beg_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.m_finish_) -
        reinterpret_cast<char*>(&_impl_.m_beg_)) + sizeof(_impl_.m_finish_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* db_activity_data::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 m_beg = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_m_beg(&has_bits);
          _impl_.m_beg_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 m_end = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_m_end(&has_bits);
          _impl_.m_end_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional bool m_start = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_m_start(&has_bits);
          _impl_.m_start_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional bool m_finish = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_m_finish(&has_bits);
          _impl_.m_finish_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // map<int64, .pbdb.db_activity.data.drawcompliance> m_drawcompliance = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.m_drawcompliance_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* db_activity_data::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pbdb.db_activity.data)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 m_beg = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        2, this->_internal_m_beg(), target);
  }

  // optional int32 m_end = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        3, this->_internal_m_end(), target);
  }

  // optional bool m_start = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        4, this->_internal_m_start(), target);
  }

  // optional bool m_finish = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        5, this->_internal_m_finish(), target);
  }

  // map<int64, .pbdb.db_activity.data.drawcompliance> m_drawcompliance = 6;
  if (!this->_internal_m_drawcompliance().empty()) {
    using MapType = ::_pb::Map<::int64_t, ::pbdb::db_activity_data_drawcompliance>;
    using WireHelper = db_activity_data_MDrawcomplianceEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_m_drawcompliance();

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterFlat<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(6, entry.first, entry.second, target, stream);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(6, entry.first, entry.second, target, stream);
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pbdb.db_activity.data)
  return target;
}

::size_t db_activity_data::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pbdb.db_activity.data)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<int64, .pbdb.db_activity.data.drawcompliance> m_drawcompliance = 6;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_m_drawcompliance_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< ::int64_t, ::pbdb::db_activity_data_drawcompliance >::const_iterator
      it = this->_internal_m_drawcompliance().begin();
      it != this->_internal_m_drawcompliance().end(); ++it) {
    total_size += db_activity_data_MDrawcomplianceEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional int32 m_beg = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_m_beg());
    }

    // optional int32 m_end = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_m_end());
    }

    // optional bool m_start = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2;
    }

    // optional bool m_finish = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData db_activity_data::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    db_activity_data::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*db_activity_data::GetClassData() const { return &_class_data_; }


void db_activity_data::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<db_activity_data*>(&to_msg);
  auto& from = static_cast<const db_activity_data&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pbdb.db_activity.data)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.m_drawcompliance_.MergeFrom(from._impl_.m_drawcompliance_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.m_beg_ = from._impl_.m_beg_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.m_end_ = from._impl_.m_end_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.m_start_ = from._impl_.m_start_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.m_finish_ = from._impl_.m_finish_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void db_activity_data::CopyFrom(const db_activity_data& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pbdb.db_activity.data)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool db_activity_data::IsInitialized() const {
  return true;
}

void db_activity_data::InternalSwap(db_activity_data* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.m_drawcompliance_.InternalSwap(&other->_impl_.m_drawcompliance_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(db_activity_data, _impl_.m_finish_)
      + sizeof(db_activity_data::_impl_.m_finish_)
      - PROTOBUF_FIELD_OFFSET(db_activity_data, _impl_.m_beg_)>(
          reinterpret_cast<char*>(&_impl_.m_beg_),
          reinterpret_cast<char*>(&other->_impl_.m_beg_));
}

::PROTOBUF_NAMESPACE_ID::Metadata db_activity_data::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_db_2eproto_getter, &descriptor_table_db_2eproto_once,
      file_level_metadata_db_2eproto[18]);
}
// ===================================================================

class db_activity::_Internal {
 public:
  using HasBits = decltype(std::declval<db_activity>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(db_activity, _impl_._has_bits_);
  static void set_has_m_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

db_activity::db_activity(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pbdb.db_activity)
}
db_activity::db_activity(const db_activity& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  db_activity* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.m_datas_){from._impl_.m_datas_}
    , decltype(_impl_.m_id_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.m_id_ = from._impl_.m_id_;
  // @@protoc_insertion_point(copy_constructor:pbdb.db_activity)
}

inline void db_activity::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.m_datas_){arena}
    , decltype(_impl_.m_id_) { ::int64_t{0} }

  };
}

db_activity::~db_activity() {
  // @@protoc_insertion_point(destructor:pbdb.db_activity)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void db_activity::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_m_datas()->~RepeatedPtrField();
}

void db_activity::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void db_activity::Clear() {
// @@protoc_insertion_point(message_clear_start:pbdb.db_activity)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_m_datas()->Clear();
  _impl_.m_id_ = ::int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* db_activity::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 m_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_m_id(&has_bits);
          _impl_.m_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .pbdb.db_activity.data m_datas = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_m_datas(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* db_activity::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pbdb.db_activity)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 m_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        1, this->_internal_m_id(), target);
  }

  // repeated .pbdb.db_activity.data m_datas = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_m_datas_size()); i < n; i++) {
    const auto& repfield = this->_internal_m_datas(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pbdb.db_activity)
  return target;
}

::size_t db_activity::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pbdb.db_activity)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .pbdb.db_activity.data m_datas = 2;
  total_size += 1UL * this->_internal_m_datas_size();
  for (const auto& msg : this->_internal_m_datas()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional int64 m_id = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_m_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData db_activity::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    db_activity::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*db_activity::GetClassData() const { return &_class_data_; }


void db_activity::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<db_activity*>(&to_msg);
  auto& from = static_cast<const db_activity&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pbdb.db_activity)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_m_datas()->MergeFrom(from._internal_m_datas());
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_set_m_id(from._internal_m_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void db_activity::CopyFrom(const db_activity& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pbdb.db_activity)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool db_activity::IsInitialized() const {
  return true;
}

void db_activity::InternalSwap(db_activity* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _internal_mutable_m_datas()->InternalSwap(other->_internal_mutable_m_datas());

  swap(_impl_.m_id_, other->_impl_.m_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata db_activity::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_db_2eproto_getter, &descriptor_table_db_2eproto_once,
      file_level_metadata_db_2eproto[19]);
}
// ===================================================================

class db_task_data_schedule::_Internal {
 public:
  using HasBits = decltype(std::declval<db_task_data_schedule>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(db_task_data_schedule, _impl_._has_bits_);
  static void set_has_m_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

db_task_data_schedule::db_task_data_schedule(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pbdb.db_task.data_schedule)
}
db_task_data_schedule::db_task_data_schedule(const db_task_data_schedule& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  db_task_data_schedule* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.m_parmint_) { from._impl_.m_parmint_ }
    ,/* _impl_._m_parmint_cached_byte_size_ = */ { 0 }

    , decltype(_impl_.m_sumint_) { from._impl_.m_sumint_ }
    ,/* _impl_._m_sumint_cached_byte_size_ = */ { 0 }

    , decltype(_impl_.m_type_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.m_type_ = from._impl_.m_type_;
  // @@protoc_insertion_point(copy_constructor:pbdb.db_task.data_schedule)
}

inline void db_task_data_schedule::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.m_parmint_) { arena }
    ,/* _impl_._m_parmint_cached_byte_size_ = */ { 0 }

    , decltype(_impl_.m_sumint_) { arena }
    ,/* _impl_._m_sumint_cached_byte_size_ = */ { 0 }

    , decltype(_impl_.m_type_) { 0 }

  };
}

db_task_data_schedule::~db_task_data_schedule() {
  // @@protoc_insertion_point(destructor:pbdb.db_task.data_schedule)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void db_task_data_schedule::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.m_parmint_.~RepeatedField();
  _impl_.m_sumint_.~RepeatedField();
}

void db_task_data_schedule::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void db_task_data_schedule::Clear() {
// @@protoc_insertion_point(message_clear_start:pbdb.db_task.data_schedule)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_m_parmint()->Clear();
  _internal_mutable_m_sumint()->Clear();
  _impl_.m_type_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* db_task_data_schedule::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 m_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_m_type(&has_bits);
          _impl_.m_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated int32 m_parmint = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_m_parmint(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<::uint8_t>(tag) == 16) {
          _internal_add_m_parmint(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated int32 m_sumint = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_m_sumint(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<::uint8_t>(tag) == 24) {
          _internal_add_m_sumint(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* db_task_data_schedule::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pbdb.db_task.data_schedule)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 m_type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        1, this->_internal_m_type(), target);
  }

  // repeated int32 m_parmint = 2;
  {
    int byte_size = _impl_._m_parmint_cached_byte_size_.Get();
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(2, _internal_m_parmint(),
                                                 byte_size, target);
    }
  }

  // repeated int32 m_sumint = 3;
  {
    int byte_size = _impl_._m_sumint_cached_byte_size_.Get();
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(3, _internal_m_sumint(),
                                                 byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pbdb.db_task.data_schedule)
  return target;
}

::size_t db_task_data_schedule::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pbdb.db_task.data_schedule)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 m_parmint = 2;
  {
    std::size_t data_size = ::_pbi::WireFormatLite::Int32Size(
        this->_internal_m_parmint())
    ;
    _impl_._m_parmint_cached_byte_size_.Set(::_pbi::ToCachedSize(data_size));
    std::size_t tag_size = data_size == 0
        ? 0
        : 1 + ::_pbi::WireFormatLite::Int32Size(
                            static_cast<int32_t>(data_size))
    ;
    total_size += tag_size + data_size;
  }

  // repeated int32 m_sumint = 3;
  {
    std::size_t data_size = ::_pbi::WireFormatLite::Int32Size(
        this->_internal_m_sumint())
    ;
    _impl_._m_sumint_cached_byte_size_.Set(::_pbi::ToCachedSize(data_size));
    std::size_t tag_size = data_size == 0
        ? 0
        : 1 + ::_pbi::WireFormatLite::Int32Size(
                            static_cast<int32_t>(data_size))
    ;
    total_size += tag_size + data_size;
  }

  // optional int32 m_type = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_m_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData db_task_data_schedule::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    db_task_data_schedule::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*db_task_data_schedule::GetClassData() const { return &_class_data_; }


void db_task_data_schedule::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<db_task_data_schedule*>(&to_msg);
  auto& from = static_cast<const db_task_data_schedule&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pbdb.db_task.data_schedule)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.m_parmint_.MergeFrom(from._impl_.m_parmint_);
  _this->_impl_.m_sumint_.MergeFrom(from._impl_.m_sumint_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_set_m_type(from._internal_m_type());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void db_task_data_schedule::CopyFrom(const db_task_data_schedule& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pbdb.db_task.data_schedule)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool db_task_data_schedule::IsInitialized() const {
  return true;
}

void db_task_data_schedule::InternalSwap(db_task_data_schedule* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.m_parmint_.InternalSwap(&other->_impl_.m_parmint_);
  _impl_.m_sumint_.InternalSwap(&other->_impl_.m_sumint_);

  swap(_impl_.m_type_, other->_impl_.m_type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata db_task_data_schedule::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_db_2eproto_getter, &descriptor_table_db_2eproto_once,
      file_level_metadata_db_2eproto[20]);
}
// ===================================================================

class db_task_data::_Internal {
 public:
  using HasBits = decltype(std::declval<db_task_data>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(db_task_data, _impl_._has_bits_);
  static void set_has_m_taskid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_m_receiveutc(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_m_finshutc(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

db_task_data::db_task_data(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pbdb.db_task.data)
}
db_task_data::db_task_data(const db_task_data& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  db_task_data* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.m_schedules_){from._impl_.m_schedules_}
    , decltype(_impl_.m_taskid_) {}

    , decltype(_impl_.m_receiveutc_) {}

    , decltype(_impl_.m_finshutc_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.m_taskid_, &from._impl_.m_taskid_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.m_finshutc_) -
    reinterpret_cast<char*>(&_impl_.m_taskid_)) + sizeof(_impl_.m_finshutc_));
  // @@protoc_insertion_point(copy_constructor:pbdb.db_task.data)
}

inline void db_task_data::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.m_schedules_){arena}
    , decltype(_impl_.m_taskid_) { 0 }

    , decltype(_impl_.m_receiveutc_) { 0 }

    , decltype(_impl_.m_finshutc_) { 0 }

  };
}

db_task_data::~db_task_data() {
  // @@protoc_insertion_point(destructor:pbdb.db_task.data)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void db_task_data::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_m_schedules()->~RepeatedPtrField();
}

void db_task_data::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void db_task_data::Clear() {
// @@protoc_insertion_point(message_clear_start:pbdb.db_task.data)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_m_schedules()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.m_taskid_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.m_finshutc_) -
        reinterpret_cast<char*>(&_impl_.m_taskid_)) + sizeof(_impl_.m_finshutc_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* db_task_data::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 m_taskid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_m_taskid(&has_bits);
          _impl_.m_taskid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 m_receiveutc = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_m_receiveutc(&has_bits);
          _impl_.m_receiveutc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 m_finshutc = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_m_finshutc(&has_bits);
          _impl_.m_finshutc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .pbdb.db_task.data_schedule m_schedules = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_m_schedules(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* db_task_data::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pbdb.db_task.data)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 m_taskid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        1, this->_internal_m_taskid(), target);
  }

  // optional int32 m_receiveutc = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        2, this->_internal_m_receiveutc(), target);
  }

  // optional int32 m_finshutc = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        3, this->_internal_m_finshutc(), target);
  }

  // repeated .pbdb.db_task.data_schedule m_schedules = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_m_schedules_size()); i < n; i++) {
    const auto& repfield = this->_internal_m_schedules(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pbdb.db_task.data)
  return target;
}

::size_t db_task_data::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pbdb.db_task.data)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .pbdb.db_task.data_schedule m_schedules = 4;
  total_size += 1UL * this->_internal_m_schedules_size();
  for (const auto& msg : this->_internal_m_schedules()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional int32 m_taskid = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_m_taskid());
    }

    // optional int32 m_receiveutc = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_m_receiveutc());
    }

    // optional int32 m_finshutc = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_m_finshutc());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData db_task_data::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    db_task_data::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*db_task_data::GetClassData() const { return &_class_data_; }


void db_task_data::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<db_task_data*>(&to_msg);
  auto& from = static_cast<const db_task_data&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pbdb.db_task.data)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_m_schedules()->MergeFrom(from._internal_m_schedules());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.m_taskid_ = from._impl_.m_taskid_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.m_receiveutc_ = from._impl_.m_receiveutc_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.m_finshutc_ = from._impl_.m_finshutc_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void db_task_data::CopyFrom(const db_task_data& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pbdb.db_task.data)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool db_task_data::IsInitialized() const {
  return true;
}

void db_task_data::InternalSwap(db_task_data* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _internal_mutable_m_schedules()->InternalSwap(other->_internal_mutable_m_schedules());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(db_task_data, _impl_.m_finshutc_)
      + sizeof(db_task_data::_impl_.m_finshutc_)
      - PROTOBUF_FIELD_OFFSET(db_task_data, _impl_.m_taskid_)>(
          reinterpret_cast<char*>(&_impl_.m_taskid_),
          reinterpret_cast<char*>(&other->_impl_.m_taskid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata db_task_data::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_db_2eproto_getter, &descriptor_table_db_2eproto_once,
      file_level_metadata_db_2eproto[21]);
}
// ===================================================================

db_task_MRundatasEntry_DoNotUse::db_task_MRundatasEntry_DoNotUse() {}
db_task_MRundatasEntry_DoNotUse::db_task_MRundatasEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void db_task_MRundatasEntry_DoNotUse::MergeFrom(const db_task_MRundatasEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata db_task_MRundatasEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_db_2eproto_getter, &descriptor_table_db_2eproto_once,
      file_level_metadata_db_2eproto[22]);
}
// ===================================================================

db_task_MCompleteddatasEntry_DoNotUse::db_task_MCompleteddatasEntry_DoNotUse() {}
db_task_MCompleteddatasEntry_DoNotUse::db_task_MCompleteddatasEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void db_task_MCompleteddatasEntry_DoNotUse::MergeFrom(const db_task_MCompleteddatasEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata db_task_MCompleteddatasEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_db_2eproto_getter, &descriptor_table_db_2eproto_once,
      file_level_metadata_db_2eproto[23]);
}
// ===================================================================

class db_task::_Internal {
 public:
  using HasBits = decltype(std::declval<db_task>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(db_task, _impl_._has_bits_);
  static void set_has_m_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

db_task::db_task(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pbdb.db_task)
}
db_task::db_task(const db_task& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  db_task* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_.m_rundatas_)*/{}
    , /*decltype(_impl_.m_completeddatas_)*/{}
    , decltype(_impl_.m_id_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.m_rundatas_.MergeFrom(from._impl_.m_rundatas_);
  _this->_impl_.m_completeddatas_.MergeFrom(from._impl_.m_completeddatas_);
  _this->_impl_.m_id_ = from._impl_.m_id_;
  // @@protoc_insertion_point(copy_constructor:pbdb.db_task)
}

inline void db_task::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_.m_rundatas_)*/{::_pbi::ArenaInitialized(), arena}
    , /*decltype(_impl_.m_completeddatas_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.m_id_) { ::int64_t{0} }

  };
}

db_task::~db_task() {
  // @@protoc_insertion_point(destructor:pbdb.db_task)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void db_task::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.m_rundatas_.~MapField();
  _impl_.m_completeddatas_.~MapField();
}

void db_task::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void db_task::Clear() {
// @@protoc_insertion_point(message_clear_start:pbdb.db_task)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.m_rundatas_.Clear();
  _impl_.m_completeddatas_.Clear();
  _impl_.m_id_ = ::int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* db_task::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 m_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_m_id(&has_bits);
          _impl_.m_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // map<int32, .pbdb.db_task.data> m_rundatas = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.m_rundatas_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // map<int32, .pbdb.db_task.data> m_completeddatas = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.m_completeddatas_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* db_task::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pbdb.db_task)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 m_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        1, this->_internal_m_id(), target);
  }

  // map<int32, .pbdb.db_task.data> m_rundatas = 2;
  if (!this->_internal_m_rundatas().empty()) {
    using MapType = ::_pb::Map<::int32_t, ::pbdb::db_task_data>;
    using WireHelper = db_task_MRundatasEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_m_rundatas();

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterFlat<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(2, entry.first, entry.second, target, stream);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(2, entry.first, entry.second, target, stream);
      }
    }
  }

  // map<int32, .pbdb.db_task.data> m_completeddatas = 3;
  if (!this->_internal_m_completeddatas().empty()) {
    using MapType = ::_pb::Map<::int32_t, ::pbdb::db_task_data>;
    using WireHelper = db_task_MCompleteddatasEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_m_completeddatas();

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterFlat<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(3, entry.first, entry.second, target, stream);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(3, entry.first, entry.second, target, stream);
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pbdb.db_task)
  return target;
}

::size_t db_task::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pbdb.db_task)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<int32, .pbdb.db_task.data> m_rundatas = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_m_rundatas_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< ::int32_t, ::pbdb::db_task_data >::const_iterator
      it = this->_internal_m_rundatas().begin();
      it != this->_internal_m_rundatas().end(); ++it) {
    total_size += db_task_MRundatasEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // map<int32, .pbdb.db_task.data> m_completeddatas = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_m_completeddatas_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< ::int32_t, ::pbdb::db_task_data >::const_iterator
      it = this->_internal_m_completeddatas().begin();
      it != this->_internal_m_completeddatas().end(); ++it) {
    total_size += db_task_MCompleteddatasEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // optional int64 m_id = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_m_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData db_task::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    db_task::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*db_task::GetClassData() const { return &_class_data_; }


void db_task::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<db_task*>(&to_msg);
  auto& from = static_cast<const db_task&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pbdb.db_task)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.m_rundatas_.MergeFrom(from._impl_.m_rundatas_);
  _this->_impl_.m_completeddatas_.MergeFrom(from._impl_.m_completeddatas_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_set_m_id(from._internal_m_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void db_task::CopyFrom(const db_task& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pbdb.db_task)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool db_task::IsInitialized() const {
  return true;
}

void db_task::InternalSwap(db_task* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.m_rundatas_.InternalSwap(&other->_impl_.m_rundatas_);
  _impl_.m_completeddatas_.InternalSwap(&other->_impl_.m_completeddatas_);

  swap(_impl_.m_id_, other->_impl_.m_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata db_task::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_db_2eproto_getter, &descriptor_table_db_2eproto_once,
      file_level_metadata_db_2eproto[24]);
}
// @@protoc_insertion_point(namespace_scope)
}  // namespace pbdb
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::pbdb::db_account*
Arena::CreateMaybeMessage< ::pbdb::db_account >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pbdb::db_account >(arena);
}
template<> PROTOBUF_NOINLINE ::pbdb::db_brief*
Arena::CreateMaybeMessage< ::pbdb::db_brief >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pbdb::db_brief >(arena);
}
template<> PROTOBUF_NOINLINE ::pbdb::db_role*
Arena::CreateMaybeMessage< ::pbdb::db_role >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pbdb::db_role >(arena);
}
template<> PROTOBUF_NOINLINE ::pbdb::item*
Arena::CreateMaybeMessage< ::pbdb::item >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pbdb::item >(arena);
}
template<> PROTOBUF_NOINLINE ::pbdb::db_bag_MItemsEntry_DoNotUse*
Arena::CreateMaybeMessage< ::pbdb::db_bag_MItemsEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pbdb::db_bag_MItemsEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::pbdb::db_bag*
Arena::CreateMaybeMessage< ::pbdb::db_bag >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pbdb::db_bag >(arena);
}
template<> PROTOBUF_NOINLINE ::pbdb::db_keyvalue*
Arena::CreateMaybeMessage< ::pbdb::db_keyvalue >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pbdb::db_keyvalue >(arena);
}
template<> PROTOBUF_NOINLINE ::pbdb::mailitem*
Arena::CreateMaybeMessage< ::pbdb::mailitem >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pbdb::mailitem >(arena);
}
template<> PROTOBUF_NOINLINE ::pbdb::mail*
Arena::CreateMaybeMessage< ::pbdb::mail >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pbdb::mail >(arena);
}
template<> PROTOBUF_NOINLINE ::pbdb::db_mail_MMailEntry_DoNotUse*
Arena::CreateMaybeMessage< ::pbdb::db_mail_MMailEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pbdb::db_mail_MMailEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::pbdb::db_mail*
Arena::CreateMaybeMessage< ::pbdb::db_mail >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pbdb::db_mail >(arena);
}
template<> PROTOBUF_NOINLINE ::pbdb::db_guild*
Arena::CreateMaybeMessage< ::pbdb::db_guild >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pbdb::db_guild >(arena);
}
template<> PROTOBUF_NOINLINE ::pbdb::db_notice*
Arena::CreateMaybeMessage< ::pbdb::db_notice >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pbdb::db_notice >(arena);
}
template<> PROTOBUF_NOINLINE ::pbdb::rankitem*
Arena::CreateMaybeMessage< ::pbdb::rankitem >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pbdb::rankitem >(arena);
}
template<> PROTOBUF_NOINLINE ::pbdb::db_ranklist_MItemEntry_DoNotUse*
Arena::CreateMaybeMessage< ::pbdb::db_ranklist_MItemEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pbdb::db_ranklist_MItemEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::pbdb::db_ranklist*
Arena::CreateMaybeMessage< ::pbdb::db_ranklist >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pbdb::db_ranklist >(arena);
}
template<> PROTOBUF_NOINLINE ::pbdb::db_activity_data_drawcompliance*
Arena::CreateMaybeMessage< ::pbdb::db_activity_data_drawcompliance >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pbdb::db_activity_data_drawcompliance >(arena);
}
template<> PROTOBUF_NOINLINE ::pbdb::db_activity_data_MDrawcomplianceEntry_DoNotUse*
Arena::CreateMaybeMessage< ::pbdb::db_activity_data_MDrawcomplianceEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pbdb::db_activity_data_MDrawcomplianceEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::pbdb::db_activity_data*
Arena::CreateMaybeMessage< ::pbdb::db_activity_data >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pbdb::db_activity_data >(arena);
}
template<> PROTOBUF_NOINLINE ::pbdb::db_activity*
Arena::CreateMaybeMessage< ::pbdb::db_activity >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pbdb::db_activity >(arena);
}
template<> PROTOBUF_NOINLINE ::pbdb::db_task_data_schedule*
Arena::CreateMaybeMessage< ::pbdb::db_task_data_schedule >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pbdb::db_task_data_schedule >(arena);
}
template<> PROTOBUF_NOINLINE ::pbdb::db_task_data*
Arena::CreateMaybeMessage< ::pbdb::db_task_data >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pbdb::db_task_data >(arena);
}
template<> PROTOBUF_NOINLINE ::pbdb::db_task_MRundatasEntry_DoNotUse*
Arena::CreateMaybeMessage< ::pbdb::db_task_MRundatasEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pbdb::db_task_MRundatasEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::pbdb::db_task_MCompleteddatasEntry_DoNotUse*
Arena::CreateMaybeMessage< ::pbdb::db_task_MCompleteddatasEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pbdb::db_task_MCompleteddatasEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::pbdb::db_task*
Arena::CreateMaybeMessage< ::pbdb::db_task >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pbdb::db_task >(arena);
}
PROTOBUF_NAMESPACE_CLOSE
// @@protoc_insertion_point(global_scope)
#include "google/protobuf/port_undef.inc"
