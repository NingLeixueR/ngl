## ngl实现了时间轮定时器，可以根据需求调整精度,<br/>
定义在[time_wheel.h]中的time_wheel<br/>
在框架中有两个地方使用了时间轮<br/>
1. 在网络模块中使用定时器进行<br/>
asio_timer 是对time_wheel的简单封装
2. 在actor_base中的定时任务也使用了时间轮<br/>
twheel 是对time_wheel的简单封装<br/>
## 时间轮的使用方法,<br/>
<br/>
主要通过int64_t time_wheel::addtimer(const wheel_parm& apram)来添加任务，<br/>
参数：wheel_parm<br/>

```cpp
struct wheel_parm
{
	int64_t					m_timerstart	= 0;				// 定时器开启的时间
	int						m_ms			= 0;				// 首次触发的毫秒
	//int					m_intervalms	= 0;				// 间隔触发的毫秒
	std::function<int(int64_t)>	m_intervalms= nullptr;			// 间隔触发的毫秒(根据传递进去的触发时间返回下次触发的间隔)
	int						m_count			= 0;				// 触发次数
	void*					m_pram			= nullptr;			// 透传参数
	std::function<void(wheel_node*)> m_fun	= nullptr;			// 定时回调函数
}; 
```

返回值是timerid,<br/>
之后我们可以使用timerid来移除定时器<br/>
移除指定定时器<br/>
void time_wheel::removetimer(int64_t atimerid)<br/>
定时器可以指定回调调用方式，<br/>
time_wheel(const time_wheel_config& aconfig = time_wheel_config(), bool aisthreadcallback = true);<br/>
1. aisthreadcallback如果为true，<br/>
使用定时器的维护的线程（定时器会专门创建一个线程进行回调，触发的任务会在队列里依次被调用）
2. aisthreadcallback如果为false，<br/>
将其放在队列里，调用std::shared_ptr<wheel_node> time_wheel::pop_node();来自行调用
