## 模块二次转发
* 在玩家正常登录后，服务器会创建一个actor_role的实例，<br/>
玩家通过消息只能与其进行交互，其他模块我们无法主动交互，<br/>
就需要借助二次转发，通过actor_role中的方法<br/>
```
  enum ecross
  {
  	ecross_ordinary,			    // 本服转发
  	ecross_cross_ordinary,		// 跨服转发
  	ecross_play,				      // 玩法转发(但是转发的actorid已确认)
  };

  // 重载(跨服模块转发)
  template <typename T>
  ecross forward_way(T& adata)
  {
  	return ecross_ordinary;
  }

  ecross forward_way(pbnet::PROBUFF_NET_CHAT& adata)
  {
  	return adata.m_channelid() == 2 ? ecross_cross_ordinary : ecross_ordinary;
  }

  template <typename T>
  int32_t dataid(T& adata)
  {
  	return nguid::none_actordataid();
  }

  template <ENUM_ACTOR ACTOR, typename T>
  bool handle_forward(message<T>& adata)
  {
  	std::shared_ptr<mforward<T>> pro(new mforward<T>(id_guid(), *adata.m_data));
  	i64_actorid lguid;
  	switch (forward_way(*adata.m_data))
  	{
  	case ecross_ordinary:
  		lguid = nguid::make(ACTOR, ttab_servers::tab()->m_area, dataid(*adata.m_data));
  		break;
  	case ecross_cross_ordinary:
  		lguid = nguid::make(ACTOR, ttab_servers::tab()->m_crossarea, dataid(*adata.m_data));
  		break;
  	case ecross_play:
  		lguid = m_playactorid;
  		break;
  	default:
  		return true;
  	}
  	send_actor(lguid, pro);
  	return true;
  }
```
通过重载[ecross forward_way(T& adata)]方法<br/>
可以指定转发的方式，跨服转发还是本服内转发，<br/>
以[pbnet::PROBUFF_NET_CHAT]为例<br/>
当m_channelid渠道id为2返回跨服转发ecross_cross_ordinary否则返回本服转发ecross_ordinary<br/>
因为actor guid构成的三要素之一 dataid，我们也可以通过重载[int32_t dataid(T& adata)],根据情况设置需要的dataid<br/>
我们在注册处理函数的时候  <br/>
1. 也需要在[void nforward::c2g()]中，
```
  // ACTOR_CHAT 模块二次转发
  register_recvforward2<EPROTOCOL_TYPE_PROTOCOLBUFF, ACTOR_CHAT>(
  	null<pbnet::PROBUFF_NET_CHAT>
  );
```
2. 需要在actor_chat<br/>
```
  void actor_chat::nregister()
  {
    // 协议注册
    register_actor<EPROTOCOL_TYPE_PROTOCOLBUFF, actor_chat>(
      false
      , dregister_fun_handle(actor_chat, mforward<pbnet::PROBUFF_NET_CHAT>)
      );
  }
```
